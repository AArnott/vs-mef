<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Microsoft.VisualStudio.Composition
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.VisualStudio.Composition;

internal class CompiledExportFactory : ExportProvider
{
	protected override object GetExport(ExportDefinition exportDefinition)
	{
		Type exportTypeDefinition = exportDefinition.Contract.Type.IsGenericType ? exportDefinition.Contract.Type.GetGenericTypeDefinition() : exportDefinition.Contract.Type;<#
foreach (var part in this.Configuration.Catalog.Parts)
{
	foreach (var partExport in part.ExportDefinitionsOnType)
	{
#>

		if (exportTypeDefinition.IsEquivalentTo(typeof(<#= GetTypeName(partExport.Contract.Type, genericTypeDefinition: true) #>)))
		{
<#
			if (partExport.Contract.ContractName == null)
			{
#>
			if (exportDefinition.Contract.ContractName == null)
<#
			}
			else
			{
#>
			if (exportDefinition.Contract.ContractName == "<#= partExport.Contract.ContractName #>")
<#
			}
#>
			{
<#
				if (part.Type.IsGenericType)
				{
#>
				var genericTemplateMethod = typeof(CompiledExportFactory).GetMethod("<#= GetPartFactoryMethodNameNoTypeArgs(part) #>", BindingFlags.Instance | BindingFlags.NonPublic);
				var genericMethod = genericTemplateMethod.MakeGenericMethod(exportDefinition.Contract.Type.GetGenericArguments());
				return genericMethod.Invoke(this, new object[0]);
<#
				}
				else
				{
#>
				return this.<#= GetPartFactoryMethodName(part) #>();
<#
				}
#>
			}
		}
<#
	}
}
#>

		throw new ArgumentException();
	}
<#
foreach (var part in this.Configuration.Parts) 
{
#>

	protected <#= GetTypeName(part.Definition.Type) #> <#= GetPartFactoryMethodName(part.Definition) #>()
	{
<#
		if (part.Definition.IsShared)
		{
#>
		Lazy<<#= GetTypeName(part.Definition.Type) #>> lazyResult;
		if (!this.TryGetSharedInstanceFactory(out lazyResult))
		{
			lazyResult = new Lazy<<#= GetTypeName(part.Definition.Type) #>>(delegate
			{
<#
				this.PushIndent("\t\t");
				EmitInstantiatePart(part);
				this.PopIndent();
#>
			});

			lazyResult = this.GetOrAddSharedInstanceFactory(lazyResult);
		}

		return lazyResult.Value;
<#
		}
		else
		{
			this.PushIndent("\t");
			EmitInstantiatePart(part);
			this.PopIndent();
		}
#>
	}
<#
}
#>
}
