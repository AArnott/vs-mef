<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Microsoft.VisualStudio.Composition
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Composition.Hosting;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.VisualStudio.Composition;

internal class CompiledExportProvider : ExportProvider
{
    public CompiledExportProvider()
        : this(null, null)
    {
    }

    public CompiledExportProvider(ExportProvider parent, string[] freshSharingBoundaries)
        : base(parent, freshSharingBoundaries)
    {
    }

    protected override object GetExport(ExportDefinition exportDefinition)
    {
        var provisionalSharedObjects = new Dictionary<Type, object>();
        Type exportTypeDefinition = exportDefinition.Contract.Type.IsGenericType ? exportDefinition.Contract.Type.GetGenericTypeDefinition() : exportDefinition.Contract.Type;<#
foreach (var contractAndExports in this.RootExportsByContract)
{
    CompositionContract contract = contractAndExports.Key;
    IEnumerable<Export> exports = contractAndExports;
    if (exports.Count() != 1)
    {
        // This method returns matches when exactly one export exists.
        continue;
    }

    var onlyExport = exports.First();
    var part = onlyExport.PartDefinition;
    var member = onlyExport.ExportingMember;
    var partExport = onlyExport.ExportDefinition;
#>

        if (<#= contract.Type.IsGenericTypeDefinition ? "exportTypeDefinition" : "exportDefinition.Contract.Type" #>.IsEquivalentTo(<#= GetTypeExpression(contract.Type, contract.Type.IsGenericTypeDefinition) #>))
        {
<#
            if (contract.ContractName == null)
            {
#>
            if (exportDefinition.Contract.ContractName == null)
<#
            }
            else
            {
#>
            if (exportDefinition.Contract.ContractName == "<#= contract.ContractName #>")
<#
            }
#>
            {
<#
                if (part.Type.IsGenericType)
                {
#>
                var genericTemplateMethod = typeof(CompiledExportProvider).GetMethod("<#= GetPartFactoryMethodNameNoTypeArgs(part) #>", BindingFlags.Instance | BindingFlags.NonPublic);
                var genericMethod = genericTemplateMethod.MakeGenericMethod(exportDefinition.Contract.Type.GetGenericArguments());
                var part = genericMethod.Invoke(this, new object[] { provisionalSharedObjects, /* nonSharedInstanceRequired: */ false });
                return <#=GetPartOrMemberLazy("part", member, partExport, part)#>;
<#
                }
                else
                {
                    if (member.IsStaticExport())
                    {
#>
                throw new InvalidOperationException("Static exports not supported.");
<#
                    }
                    else
                    {
#>
                var part = this.<#= GetPartFactoryMethodName(part) #>(provisionalSharedObjects);
                return <#=GetPartOrMemberLazy("part", member, partExport, part)#>;
<#
                    }
                }
#>
            }
        }
<#
}
#>

        throw new CompositionFailedException();
    }

    protected override IEnumerable<object> GetExports(ExportDefinition exportDefinition)
    {
        var provisionalSharedObjects = new Dictionary<Type, object>();
        Type exportTypeDefinition = exportDefinition.Contract.Type.IsGenericType ? exportDefinition.Contract.Type.GetGenericTypeDefinition() : exportDefinition.Contract.Type;<#
foreach (var contractAndExports in this.RootExportsByContract)
{
    CompositionContract contract = contractAndExports.Key;
    IEnumerable<Export> exports = contractAndExports;

#>

        if (<#= contract.Type.IsGenericTypeDefinition ? "exportTypeDefinition" : "exportDefinition.Contract.Type" #>.IsEquivalentTo(<#= GetTypeExpression(contract.Type, contract.Type.IsGenericTypeDefinition) #>))
        {
<#
            if (contract.ContractName == null)
            {
#>
            if (exportDefinition.Contract.ContractName == null)
<#
            }
            else
            {
#>
            if (exportDefinition.Contract.ContractName == "<#= contract.ContractName #>")
<#
            }
#>
            {
                <# EmitGetExportsReturnExpression(contract, exports); #>
            }
        }
<#
}
#>

        throw new CompositionFailedException();
    }
<#
foreach (var part in this.Configuration.Parts) 
{
#>

    protected ILazy<<#= GetTypeName(part.Definition.Type) #>> <#= GetPartFactoryMethodName(part.Definition) #>(Dictionary<Type, object> provisionalSharedObjects, bool nonSharedInstanceRequired = false)
    {
        ILazy<<#= GetTypeName(part.Definition.Type) #>> value;
        Type partType = <#= this.GetTypeExpression(part.Definition.Type) #>;
        if (!nonSharedInstanceRequired && TryGetProvisionalSharedExport(provisionalSharedObjects, partType, out value))
        {
            return value;
        }

        ILazy<<#= GetTypeName(part.Definition.Type) #>> lazyResult;
<#
        if (part.Definition.IsShared)
        {
#>
        if (nonSharedInstanceRequired || !this.TryGetSharedInstanceFactory(@"<#= part.Definition.SharingBoundary #>", partType, out lazyResult))
        {
            lazyResult = <# using (EmitLazyConstruction(part.Definition.Type)) { #>
                {
<#
                if (part.Definition.IsInstantiable)
                {
                    using(Indent(5))
                    {
                        EmitInstantiatePart(part);
                    }
                }
                else
                {
#>
                    return CannotInstantiatePartWithNoImportingConstructor();
<#
                }
#>
                }<# } #>;

            if (!nonSharedInstanceRequired)
            {
                lazyResult = this.GetOrAddSharedInstanceFactory(@"<#= part.Definition.SharingBoundary #>", partType, lazyResult);
            }
        }
<#
        }
        else
        {
#>
        lazyResult = <# using (EmitLazyConstruction(part.Definition.Type)) { #>
            {
<#
                using(Indent(4))
                {
                    if (part.Definition.IsInstantiable)
                    {
                        EmitInstantiatePart(part);
                    }
                    else
                    {
#>
                return CannotInstantiatePartWithNoImportingConstructor();
<#
                    }
                }
#>
            }<# } #>;
<#
        }
#>

        return lazyResult;
    }
<#
}
#>

    private static bool TryGetProvisionalSharedExport<T>(IReadOnlyDictionary<Type, object> provisionalSharedObjects, Type type, out ILazy<T> value)
    {
        object valueObject;
        if (provisionalSharedObjects.TryGetValue(type, out valueObject))
        {
            value = LazyPart.Wrap((T)valueObject);
            return true;
        }

        value = null;
        return false;
    }
<#
    // Emit concrete types for each metadataview interface.
    foreach (Type interfaceType in GetMetadataViewInterfaces())
    {
        string className = GetClassNameForMetadataView(interfaceType);
#>

    private class <#= className #> : <#= GetTypeName(interfaceType) #>
    {
<#
        foreach (var member in interfaceType.EnumProperties(BindingFlags.Instance | BindingFlags.Public).Distinct(UniquePropertyNameComparer.Default))
        {
#>
        private readonly <#= GetTypeName(member.PropertyType) #> <#= member.Name #>;
<#
        }
#>

        internal <#= className #>(IReadOnlyDictionary<string, object> source)
        {
<#
        foreach (var member in interfaceType.EnumProperties(BindingFlags.Instance | BindingFlags.Public).Distinct(UniquePropertyNameComparer.Default))
        {
#>
            this.<#= member.Name #> = <#= GetValueOrDefaultForMetadataView(member, "source") #>;
<#
        }
#>
        }
<#
        foreach (var member in interfaceType.EnumProperties(BindingFlags.Instance | BindingFlags.Public))
        {
#>

        <#= GetTypeName(member.PropertyType) #> <#= GetTypeName(member.DeclaringType) #>.<#= member.Name #>
        {
            get { return this.<#= member.Name #>; }
        }
<#
        }
#>
    }
<#
    }
#>
}
