<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.VisualStudio.Composition;

internal class CompiledExportFactory : ExportFactory
{
	protected override object GetExport(ExportDefinition exportDefinition)
	{<#
foreach (var part in this.Configuration.Catalog.Parts)
{
	foreach (var partExport in part.ExportDefinitionsOnType)
	{
#>

		if (exportDefinition.Contract.Type.IsEquivalentTo(typeof(<#= GetTypeName(partExport.Contract.Type) #>)))
		{
<#
			if (partExport.Contract.ContractName == null)
			{
#>
			if (exportDefinition.Contract.ContractName == null)
<#
			}
			else
			{
#>
			if (exportDefinition.Contract.ContractName == "<#= partExport.Contract.ContractName #>")
<#
			}
#>
			{
				return this.GetOrCreate<#= part.Id #>();
			}
		}
<#
	}
}
#>

		throw new ArgumentException();
	}
<#
foreach (var part in this.Configuration.Parts) 
{
#>

	protected <#= GetTypeName(part.Definition.Type) #> GetOrCreate<#= part.Definition.Id #>()
	{
		var result = new <#= GetTypeName(part.Definition.Type) #>();
<#
	foreach (var satisfyingExport in part.SatisfyingExports)
	{
		var importingMember = satisfyingExport.Key.ImportingMember;
		var importDefinition = satisfyingExport.Key.ImportDefinition;
		var exports = satisfyingExport.Value;
		string fullTypeNameWithPerhapsLazy = GetTypeName(importDefinition.CoercedValueType);
		if (importDefinition.IsLazy)
		{
			fullTypeNameWithPerhapsLazy = "Lazy<" + fullTypeNameWithPerhapsLazy + ">";
		}

		string left = "result." + importingMember.Name;
		if (importDefinition.Cardinality == ImportCardinality.ZeroOrMore)
		{
			string right = "new List<" + fullTypeNameWithPerhapsLazy + "> {";
			foreach (var export in exports)
			{
				right += "\n\t\t\tthis.GetOrCreate" + export.PartDefinition.Id + "(),";
			}

			right += "\n\t\t}";
			if (importDefinition.IsLazy)
			{
			}
#>
		<#= left #> = <#= right #>;
<#
		}
		else if (exports.Any())
		{
			string right = "this.GetOrCreate" + exports.Single().PartDefinition.Id + "()";
			if (importDefinition.IsLazy)
			{
				right = "new " + fullTypeNameWithPerhapsLazy + "(() => " + right + ")";
			}

#>
		<#= left #> = <#= right #>;
<#
		}
	}
#>
		return result;
	}
<#
}
#>
}

<#+
	public CompositionConfiguration Configuration { get; set; }

	private static string GetTypeName(Type type)
	{
		if (type.DeclaringType != null)
		{
			return GetTypeName(type.DeclaringType) + "." + type.Name;
		}
		else
		{
			return type.FullName;
		}
	}
#>