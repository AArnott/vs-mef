<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Microsoft.VisualStudio.Composition
//  
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.VisualStudio.Composition;

internal class CompiledExportProvider : ExportProvider
{
	protected override object GetExport(ExportDefinition exportDefinition)
	{
		var provisionalSharedObjects = new Dictionary<Type, object>();
		var provisionalDisposableObjects = new List<IDisposable>();
		try
		{
			Type exportTypeDefinition = exportDefinition.Contract.Type.IsGenericType ? exportDefinition.Contract.Type.GetGenericTypeDefinition() : exportDefinition.Contract.Type;<#
foreach (var part in this.Configuration.Catalog.Parts)
{
	foreach (var partExportPair in part.ExportDefinitions)
	{
		var member = partExportPair.Key;
		var partExport = partExportPair.Value;
#>

			if (<#= partExport.Contract.Type.IsGenericTypeDefinition ? "exportTypeDefinition" : "exportDefinition.Contract.Type" #>.IsEquivalentTo(typeof(<#= GetTypeName(partExport.Contract.Type, partExport.Contract.Type.IsGenericTypeDefinition) #>)))
			{
<#
			if (partExport.Contract.ContractName == null)
			{
#>
				if (exportDefinition.Contract.ContractName == null)
<#
			}
			else
			{
#>
				if (exportDefinition.Contract.ContractName == "<#= partExport.Contract.ContractName #>")
<#
			}
#>
				{
<#
				if (part.Type.IsGenericType)
				{
#>
					var genericTemplateMethod = typeof(CompiledExportProvider).GetMethod("<#= GetPartFactoryMethodNameNoTypeArgs(part) #>", BindingFlags.Instance | BindingFlags.NonPublic);
					var genericMethod = genericTemplateMethod.MakeGenericMethod(exportDefinition.Contract.Type.GetGenericArguments());
					var part = genericMethod.Invoke(this, new object[] { provisionalDisposableObjects, provisionalSharedObjects });
					return <#=GetPartOrMemberLazy("part", member, partExport)#>;
<#
				}
				else
				{
#>
					var part = this.<#= GetPartFactoryMethodName(part) #>(provisionalDisposableObjects, provisionalSharedObjects);
					return <#=GetPartOrMemberLazy("part", member, partExport)#>;
<#
				}
#>
				}
			}
<#
	}
}
#>

			throw new ArgumentException();
		}
		catch
		{
			foreach (var item in provisionalDisposableObjects)
			{
				try
				{
					item.Dispose();
				}
				catch (Exception ex)
				{
					////Debug.Fail(ex.Message);
					throw;
				}
			}

			throw;
		}
	}
<#
foreach (var part in this.Configuration.Parts) 
{
#>

	protected ILazy<<#= GetTypeName(part.Definition.Type) #>> <#= GetPartFactoryMethodName(part.Definition) #>(List<IDisposable> provisionalDisposableObjects, Dictionary<Type, object> provisionalSharedObjects)
	{
		ILazy<<#= GetTypeName(part.Definition.Type) #>> value;
		if (TryGetProvisionalSharedExport(provisionalSharedObjects, out value))
		{
			return value;
		}

		ILazy<<#= GetTypeName(part.Definition.Type) #>> lazyResult;
<#
		if (part.Definition.IsShared)
		{
#>
		if (!this.TryGetSharedInstanceFactory(out lazyResult))
		{
			lazyResult = new LazyPart<<#= GetTypeName(part.Definition.Type) #>>(
				delegate
				{
<#
				this.PushIndent("\t\t\t");
				EmitInstantiatePart(part);
				this.PopIndent();
#>
				});

			lazyResult = this.GetOrAddSharedInstanceFactory(lazyResult);
		}
<#
		}
		else
		{
#>
		lazyResult = new LazyPart<<#= GetTypeName(part.Definition.Type) #>>(
			delegate
			{
<#
				this.PushIndent("\t\t");
				EmitInstantiatePart(part);
				this.PopIndent();
#>
			});
<#
		}
#>

		return lazyResult;
	}
<#
}
#>

	private static bool TryGetProvisionalSharedExport<T>(Dictionary<Type, object> provisionalSharedObjects, out ILazy<T> value)
	{
		object valueObject;
		if (provisionalSharedObjects.TryGetValue(typeof(T), out valueObject))
		{
			value = LazyPart.Wrap((T)valueObject);
			return true;
		}

		value = null;
		return false;
	}
}
