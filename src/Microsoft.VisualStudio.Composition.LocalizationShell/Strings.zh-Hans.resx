<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CannotDirectlyDisposeAnImport" xml:space="preserve">
    <value>此示例为导入，且不可直接释放。</value>
  </data>
  <data name="ContainerDisposalEncounteredExceptions" xml:space="preserve">
    <value>实例化的部件从 IDisposable.Dispose() 中引发异常。</value>
  </data>
  <data name="ErrorsDuringDiscovery" xml:space="preserve">
    <value>在搜索过程中出现错误。</value>
  </data>
  <data name="ErrorsInComposition" xml:space="preserve">
    <value>撰写中存在错误。</value>
  </data>
  <data name="ErrorWhileSettingImport" xml:space="preserve">
    <value>无法满足导入“{0}”。</value>
  </data>
  <data name="ExceptionThrownByPartUnderInitialization" xml:space="preserve">
    <value>参初始化部件“{0}”时引发了异常。</value>
  </data>
  <data name="ExportedValueNotAssignableToImport" xml:space="preserve">
    <value>从“{0}”导出的值无法分配到导入站点“{1}”。</value>
  </data>
  <data name="FailStableComposition" xml:space="preserve">
    <value>无法找到稳定的组合。</value>
  </data>
  <data name="FailureWhileScanningType" xml:space="preserve">
    <value>扫描类型“{0}”时失败。</value>
  </data>
  <data name="NoImportingConstructor" xml:space="preserve">
    <value>无导入构造函数。</value>
  </data>
  <data name="PartBelongsToAnotherSharingBoundary" xml:space="preserve">
    <value>从属于其他共享边界的部件导出的请求不合适。</value>
  </data>
  <data name="PartIsNotInstantiable" xml:space="preserve">
    <value>此部件({0})无法实例化。</value>
  </data>
  <data name="ReflectionTypeLoadExceptionWhileEnumeratingTypes" xml:space="preserve">
    <value>枚举程序集“{0}”中的类型时，为 ReflectionTypeLoadException。结果将是不完整的。</value>
  </data>
  <data name="ScanningMEFAssemblies" xml:space="preserve">
    <value>正在扫描 MEF 组件...</value>
  </data>
  <data name="TypeOfMetadataViewUnsupported" xml:space="preserve">
    <value>元数据视图类型不受支持。</value>
  </data>
  <data name="UnableToDeterminePrimarySharingBoundary" xml:space="preserve">
    <value>无法确定 MEF 部件“{0}”的主要共享边界。</value>
  </data>
  <data name="UnableToEnumerateTypes" xml:space="preserve">
    <value>无法枚举程序集“{0}”中的类型。</value>
  </data>
  <data name="UnableToInstantiateCustomImportCollectionType" xml:space="preserve">
    <value>无法实例化自定义导入集合类型。</value>
  </data>
  <data name="UnableToLoadAssembly" xml:space="preserve">
    <value>无法加载用于扫描的程序集“{0}”。</value>
  </data>
  <data name="UnexpectedMemberType" xml:space="preserve">
    <value>意外的成员类型。</value>
  </data>
  <data name="UnexpectedNumberOfExportsFound" xml:space="preserve">
    <value>预期具有协定名称“{1}”的 {0} 导出，但在实施相应约束后发现 {2}。</value>
  </data>
  <data name="UnexpectedSharedPartState" xml:space="preserve">
    <value>此共享部件处于 {0} 状态，但是对于此操作必须处于 {1} 状态。</value>
  </data>
  <data name="AllValuesMustBeNonNull" xml:space="preserve">
    <value>所有值必须都为非空。</value>
  </data>
  <data name="CannotImportBecauseExportingPartCannotBeInstantiated" xml:space="preserve">
    <value>{0}: 无法导入从 {1} 中导出的值，因为导出部件无法实例化。是否丢失导入构造函数？</value>
  </data>
  <data name="CollectionTypeMustDeriveFromICollectionOfT" xml:space="preserve">
    <value>集合类型必须派生自 ICollection&lt;T&gt;。</value>
  </data>
  <data name="ExactlyOneEntryForEveryImport" xml:space="preserve">
    <value>每个导入应只有一个条目。</value>
  </data>
  <data name="ExpectedExactlyOneExportButFound" xml:space="preserve">
    <value>{0}: 预期刚好 1 个 {1} 的导出，但发现 {2}。{3}</value>
  </data>
  <data name="ExpectedOneOrZeroExportsButFound" xml:space="preserve">
    <value>{0}: 预期 1 个或 0 个 {1} 的导出，但发现 {2}。{3}</value>
  </data>
  <data name="ExportOfExportProviderNotAllowed" xml:space="preserve">
    <value>{0}: 不允许 ExportProvider 的导出。</value>
  </data>
  <data name="ImportingCtorHasUnsupportedParameterTypeForImportMany" xml:space="preserve">
    <value>导入构造函数有一个不受支持的参数类型为 [ImportMany]。支持唯一 T [] 和 IEnumerable &lt;T&gt;  。</value>
  </data>
  <data name="ImportsThatUseGenericTypeParametersNotSupported" xml:space="preserve">
    <value>{0}: 不支持使用泛型类型参数的导入。</value>
  </data>
  <data name="InstanceEmpty" xml:space="preserve">
    <value>此实例为空。</value>
  </data>
  <data name="IsNotAssignableFromExportedMEFValue" xml:space="preserve">
    <value>{0}: 不可从导出的 MEF 值 {1} 中分配。</value>
  </data>
  <data name="LoopBetweenNonSharedParts" xml:space="preserve">
    <value>非共享部件之间循环。</value>
  </data>
  <data name="LoopInvolvingImportingCtorArgumentAndAllNonLazyImports" xml:space="preserve">
    <value>循环涉及 ImportingConstructor 参数和所有非延迟导入。</value>
  </data>
  <data name="MetadataTypeNotSupported" xml:space="preserve">
    <value>{0}: 不支持元数据类型 {1}。</value>
  </data>
  <data name="NotATypeSpec" xml:space="preserve">
    <value>不是类型规范。</value>
  </data>
  <data name="NotClosedFormOfOther" xml:space="preserve">
    <value>不是另一个的关闭窗体。</value>
  </data>
  <data name="NotGenericTypeDefinition" xml:space="preserve">
    <value>这不是泛型类型的定义。</value>
  </data>
  <data name="NotInitialized" xml:space="preserve">
    <value>未初始化。</value>
  </data>
  <data name="PartIsNotShared" xml:space="preserve">
    <value>部件未共享。</value>
  </data>
  <data name="UnresolvableMetadataToken" xml:space="preserve">
    <value>无法解析的元数据标记。</value>
  </data>
  <data name="WrongLength" xml:space="preserve">
    <value>长度错误。</value>
  </data>
  <data name="RecursiveRequestForPartConstruction" xml:space="preserve">
    <value>无法构造 MEF 部分"{0}"由于无法解析递归构造请求。</value>
  </data>
  <data name="AssemblyNameMustBeSetFirst" xml:space="preserve">
    <value>必须首先设置 AssemblyName。</value>
  </data>
  <data name="CannotBeEmpty" xml:space="preserve">
    <value>不得为空。</value>
  </data>
  <data name="CollectionMustBePublicAndPublicCtorWhenUsingImportingCtor" xml:space="preserve">
    <value>配合 [ImportingConstructor] 使用时，集合必须将公共构造函数公开。</value>
  </data>
  <data name="CompilerErrorsOccurred" xml:space="preserve">
    <value>出现编译错误。</value>
  </data>
  <data name="CustomImportSourceNotSupported" xml:space="preserve">
    <value>尚不支持自定义的导入源。</value>
  </data>
  <data name="DiscoveredIdenticalPropertiesInMetadataAttributesForPart" xml:space="preserve">
    <value>成员"{0}"包含元数据属性具有相同的属性名称。属性名称:"{1}"。</value>
    <comment>{0} = member (full name if possible) with invalid metadata attributes.
{1} = the property's name.</comment>
  </data>
  <data name="ExportsOnMembersNotAllowedWhenDeclaringTypeGeneric" xml:space="preserve">
    <value>声明类型为泛型时，不允许导出成员。</value>
  </data>
  <data name="FailedToGenerateEmbeddableTypes" xml:space="preserve">
    <value>无法生成可嵌入的类型。</value>
  </data>
  <data name="ImportConstraintTypeNotSupported" xml:space="preserve">
    <value>不支持导入约束类型 {0}。</value>
  </data>
  <data name="IsExpectedOnlyOnImportsOfExportFactoryOfT" xml:space="preserve">
    <value>{0} 预计仅对进口的 ExportFactory&lt;T&gt;。</value>
  </data>
  <data name="IsExportFactoryExpectedTrue" xml:space="preserve">
    <value>IsExportFactory 预计为 true。</value>
  </data>
  <data name="MemberContainsBothImportAndImportMany" xml:space="preserve">
    <value>成员“{0}”包含 ImportAttribute 和 ImportManyAttribute。</value>
  </data>
  <data name="NoImportingConstructorFound" xml:space="preserve">
    <value>找不到导入构造函数。</value>
  </data>
  <data name="NoMemberToSatisfy" xml:space="preserve">
    <value>没有成员满足。</value>
  </data>
  <data name="OnImportsSatisfiedTakeNoParameters" xml:space="preserve">
    <value>OnImportsSatisfied 方法不需要参数。</value>
  </data>
  <data name="OnlyOneOnImportsSatisfiedMethodIsSupported" xml:space="preserve">
    <value>仅支持一个 OnImportsSatisfied 方法。</value>
  </data>
  <data name="OnlySupportedOnWriteOperations" xml:space="preserve">
    <value>仅在写入操作中受支持。</value>
  </data>
  <data name="ReadableStreamRequired" xml:space="preserve">
    <value>所需的可读取流。</value>
    <comment>'stream' is in reference to System.IO.Stream</comment>
  </data>
  <data name="TypeMustDefineMemberInfoOrDerivedType" xml:space="preserve">
    <value>类型必须为定义 memberInfo 的类型或派生类型。</value>
  </data>
  <data name="UnexpectedConstraintType" xml:space="preserve">
    <value>意外的约束类型: {0}。</value>
  </data>
  <data name="UnsupportedFormat" xml:space="preserve">
    <value>不受支持的格式: {0}。</value>
  </data>
  <data name="WritableStreamRequired" xml:space="preserve">
    <value>所需的可写入流。</value>
    <comment>'stream' is in reference to System.IO.Stream</comment>
  </data>
  <data name="WrongType" xml:space="preserve">
    <value>错误类型。</value>
  </data>
</root>