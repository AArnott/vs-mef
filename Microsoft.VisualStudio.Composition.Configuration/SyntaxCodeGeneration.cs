namespace Microsoft.VisualStudio.Composition
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Threading.Tasks;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Validation;

    internal class SyntaxCodeGeneration
    {
        private const string GeneratedByCodeComment = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Microsoft.VisualStudio.Composition
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
";

        private const string InstantiatedPartLocalVarName = "result";

        private static readonly TypeSyntax dictionaryOfIntObject = SyntaxFactory.GenericName("Dictionary")
                    .WithTypeArgumentList(SyntaxFactory.TypeArgumentList(CodeGen.JoinSyntaxNodes<TypeSyntax>(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                        SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword)))));

        private static readonly ObjectCreationExpressionSyntax newDictionaryOfTypeObjectExpression =
            SyntaxFactory.ObjectCreationExpression(dictionaryOfIntObject, SyntaxFactory.ArgumentList(), null);

        private static readonly LiteralExpressionSyntax NullSyntax = SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression);

        private readonly HashSet<Assembly> relevantAssemblies = new HashSet<Assembly>();

        private readonly HashSet<Type> relevantEmbeddedTypes = new HashSet<Type>();

        /// <summary>
        /// Additional members of the generated ExportProvider-derived type to emit.
        /// </summary>
        private readonly List<MemberDeclarationSyntax> extraMembers = new List<MemberDeclarationSyntax>();

        /// <summary>
        /// The list of assemblies that need to be referenced by the generated code.
        /// </summary>
        private readonly List<Assembly> reflectionLoadedAssemblies = new List<Assembly>();

        /// <summary>
        /// The list of types that need to be referenced by the generated code.
        /// </summary>
        private readonly List<Type> reflectionLoadedTypes = new List<Type>();

        /// <summary>
        /// A collection of symbols defined at the level of the generated class.
        /// </summary>
        /// <remarks>
        /// This is useful to ensure that any generated symbol is unique.
        /// </remarks>
        private readonly HashSet<string> classSymbols = new HashSet<string>();

        /// <summary>
        /// A set of local variable names that have already been used in the currently generating part factory method.
        /// </summary>
        private readonly HashSet<string> localSymbols = new HashSet<string>();

        /// <summary>
        /// A lookup table of arbitrary objects to the symbols that have been reserved for them.
        /// </summary>
        private readonly Dictionary<object, string> reservedSymbols = new Dictionary<object, string>();

        public CompositionConfiguration Configuration { get; set; }

        /// <summary>
        /// Gets the relevant assemblies that must be referenced when compiling the generated code.
        /// </summary>
        public ISet<Assembly> RelevantAssemblies
        {
            get { return this.relevantAssemblies; }
        }

        /// <summary>
        /// Gets the relevant embedded types that must be discoverable when compiling the generated code.
        /// </summary>
        public ISet<Type> RelevantEmbeddedTypes
        {
            get { return this.relevantEmbeddedTypes; }
        }

        private string GetGetExportsCoreHelperMethodName(string contractName)
        {
            return "GetExportsCore_" + Utilities.MakeIdentifierNameSafe(contractName);
        }

        private string GetGetExportsCoreMethodDeclaringTypeName(string contractName)
        {
            return HashIdentifierAcrossBuckets("GetExportsCoreHelpers", contractName, 20);
        }

        private MethodDeclarationSyntax CreateGetExportsCoreMethod()
        {
            var importDefinition = SyntaxFactory.IdentifierName("importDefinition");

            var switchSections = new List<SwitchSectionSyntax>();
            foreach (var exportsByContract in this.ExportsByContract)
            {
                var switchLabel = SyntaxFactory.SwitchLabel(
                    SyntaxKind.CaseSwitchLabel,
                    SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(exportsByContract.Key)));

                var returnStatement = SyntaxFactory.ReturnStatement(
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName(GetGetExportsCoreMethodDeclaringTypeName(exportsByContract.Key)),
                            SyntaxFactory.IdentifierName(GetGetExportsCoreHelperMethodName(exportsByContract.Key))),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(SyntaxFactory.ThisExpression()),
                            SyntaxFactory.Argument(SyntaxFactory.IdentifierName("importDefinition"))))));

                switchSections.Add(SyntaxFactory.SwitchSection(
                    SyntaxFactory.SingletonList(switchLabel),
                    SyntaxFactory.SingletonList<StatementSyntax>(returnStatement)));
            }

            switchSections.Add(SyntaxFactory.SwitchSection(
                SyntaxFactory.SingletonList(SyntaxFactory.SwitchLabel(SyntaxKind.DefaultSwitchLabel)),
                SyntaxFactory.SingletonList<StatementSyntax>(SyntaxFactory.ReturnStatement(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        this.GetTypeNameSyntax(typeof(ImmutableList<Export>)),
                        SyntaxFactory.IdentifierName("Empty"))))));

            // protected override IEnumerable<Export> GetExportsCore(ImportDefinition importDefinition)
            var method = SyntaxFactory.MethodDeclaration(
                this.GetTypeNameSyntax(typeof(IEnumerable<Export>)),
                "GetExportsCore")
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(importDefinition.Identifier).WithType(this.GetTypeNameSyntax(typeof(ImportDefinition))))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
                    SyntaxFactory.Token(SyntaxKind.OverrideKeyword))
                .WithBody(SyntaxFactory.Block(
                    SyntaxFactory.SwitchStatement(SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        importDefinition,
                        SyntaxFactory.IdentifierName("ContractName")))
                        .WithSections(SyntaxFactory.List(switchSections))));

            return method;
        }

        private const string CompiledExportProviderTypeName = "CompiledExportProvider";

        private ConstructorDeclarationSyntax CreateDefaultConstructor()
        {
            // public CompiledExportProvider() : this(null, null) { }
            return SyntaxFactory.ConstructorDeclaration(CompiledExportProviderTypeName)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .WithInitializer(
                    SyntaxFactory.ConstructorInitializer(
                        SyntaxKind.ThisConstructorInitializer,
                        SyntaxFactory.ArgumentList(
                            SyntaxFactory.SeparatedList(CodeGen.JoinSyntaxNodes(
                                SyntaxKind.CommaToken,
                                SyntaxFactory.Argument(NullSyntax),
                                SyntaxFactory.Argument(NullSyntax))))))
                .WithBody(SyntaxFactory.Block());
        }

        private ConstructorDeclarationSyntax CreateScopingConstructor()
        {
            var parentIdentifier = SyntaxFactory.IdentifierName("parent");
            var freshSharingBoundaries = SyntaxFactory.IdentifierName("freshSharingBoundaries");

            // public CompiledExportProvider(ExportProvider parent, string[] freshSharingBoundaries) 
            //    : base(parent, freshSharingBoundaries)
            return SyntaxFactory.ConstructorDeclaration(CompiledExportProviderTypeName)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(parentIdentifier.Identifier).WithType(this.GetTypeNameSyntax(typeof(ExportProvider))),
                    SyntaxFactory.Parameter(freshSharingBoundaries.Identifier).WithType(this.GetTypeNameSyntax(typeof(string[]))))
                .WithInitializer(
                    SyntaxFactory.ConstructorInitializer(
                        SyntaxKind.BaseConstructorInitializer,
                        SyntaxFactory.ArgumentList(
                            SyntaxFactory.SeparatedList(CodeGen.JoinSyntaxNodes(
                                SyntaxKind.CommaToken,
                                SyntaxFactory.Argument(parentIdentifier),
                                SyntaxFactory.Argument(freshSharingBoundaries))))))
                .WithBody(SyntaxFactory.Block(
                // this.assemblyNames
                    SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.ThisExpression(),
                            SyntaxFactory.IdentifierName("assemblyNames")),
                        SyntaxFactory.ArrayCreationExpression(SyntaxFactory.ArrayType(
                            this.GetTypeNameSyntax(typeof(string)),
                            SyntaxFactory.SingletonList(SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(this.reflectionLoadedAssemblies.Count)))))),
                            SyntaxFactory.InitializerExpression(
                                SyntaxKind.ArrayInitializerExpression,
                                CodeGen.JoinSyntaxNodes(
                                    SyntaxKind.CommaToken,
                                    this.reflectionLoadedAssemblies.Select(a => GetSyntaxToReconstructValue(a.FullName, SyntaxFactory.ThisExpression())).ToArray()))))),
                // this.assemblyCodeBasePaths
                    SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.ThisExpression(),
                            SyntaxFactory.IdentifierName("assemblyCodeBasePaths")),
                        SyntaxFactory.ArrayCreationExpression(SyntaxFactory.ArrayType(
                            this.GetTypeNameSyntax(typeof(string)),
                            SyntaxFactory.SingletonList(SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(this.reflectionLoadedAssemblies.Count)))))),
                            SyntaxFactory.InitializerExpression(
                                SyntaxKind.ArrayInitializerExpression,
                                CodeGen.JoinSyntaxNodes(
                                    SyntaxKind.CommaToken,
                                    this.reflectionLoadedAssemblies.Select(a => GetSyntaxToReconstructValue(a.CodeBase, SyntaxFactory.ThisExpression())).ToArray()))))),
                // this.cachedManifests = new Module[<#= reflectionLoadedAssemblies.Count #>];
                    SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.ThisExpression(),
                            SyntaxFactory.IdentifierName("cachedManifests")),
                        SyntaxFactory.ArrayCreationExpression(SyntaxFactory.ArrayType(
                            this.GetTypeNameSyntax(typeof(Module)),
                            SyntaxFactory.SingletonList(SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(this.reflectionLoadedAssemblies.Count))))))))),
                // this.cachedTypes = new Type[<#= reflectionLoadedTypes.Count #>];
                    SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.ThisExpression(),
                            SyntaxFactory.IdentifierName("cachedTypes")),
                        SyntaxFactory.ArrayCreationExpression(SyntaxFactory.ArrayType(
                            this.GetTypeNameSyntax(typeof(Type)),
                            SyntaxFactory.SingletonList(SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(this.reflectionLoadedTypes.Count)))))))))));
        }

        internal CompilationUnitSyntax CreateSourceFile()
        {
            var partFactoryNestedTypes =
                from part in this.Configuration.Parts.Where(p => p.Definition.IsInstantiable)
                group part by GetPartFactoryDeclaringTypeName(part.Definition) into partsByDeclaringType
                select SyntaxFactory.ClassDeclaration(partsByDeclaringType.Key)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                    .AddMembers(partsByDeclaringType.Select(part => this.CreateInstantiatePartMethod(part)).ToArray());

            var importDefinition = SyntaxFactory.IdentifierName("importDefinition");
            var getExportsCoreHelperNestedTypes =
                from contractName in this.ExportsByContract
                group contractName by this.GetGetExportsCoreMethodDeclaringTypeName(contractName.Key) into helperMethods
                select SyntaxFactory.ClassDeclaration(helperMethods.Key)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                    .AddMembers(helperMethods.Select(contractName => CreateGetExportsCoreHelperMethod(contractName, importDefinition)).ToArray());

            var compiledExportProviderType = SyntaxFactory.ClassDeclaration(CompiledExportProviderTypeName)
                .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.InternalKeyword)))
                .WithBaseList(SyntaxFactory.BaseList(SyntaxFactory.SingletonSeparatedList<TypeSyntax>(
                    SyntaxFactory.IdentifierName("ExportProvider"))))
                .AddMembers(partFactoryNestedTypes.ToArray())
                .AddMembers(getExportsCoreHelperNestedTypes.ToArray())
                .AddMembers(this.GetMetadataViewInterfaces().Select(CreateMetadataViewClass).ToArray())
                .AddMembers(this.CreateGetExportsCoreMethod())
                .AddMembers(
                    this.CreateGetTypeIdCoreMethod(),
                    this.CreateGetTypeCoreMethod(),
                    this.CreateDefaultConstructor(),
                    this.CreateScopingConstructor())
                .AddMembers(this.extraMembers.ToArray());

            var unit = SyntaxFactory.CompilationUnit()
                .WithUsings(SyntaxFactory.List(new[] {
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Generic")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Immutable")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Composition.Hosting")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Diagnostics")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Linq")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Reflection")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Microsoft.VisualStudio")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Microsoft.VisualStudio.Composition")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.NameEquals("CompositionFailedException"), SyntaxFactory.ParseName("Microsoft.VisualStudio.Composition.CompositionFailedException")),
                    }))
                .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(compiledExportProviderType));

            // Add the code generation comment at the top.
            unit = unit.WithLeadingTrivia(SyntaxFactory.Comment(GeneratedByCodeComment));

            return unit;
        }

        private static readonly TypeSyntax readonlyDictionaryOfStringObjectSyntax =
            SyntaxFactory.GenericName("IReadOnlyDictionary").AddTypeArgumentListArguments(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword)));

        private ClassDeclarationSyntax CreateMetadataViewClass(Type interfaceType)
        {
            Requires.NotNull(interfaceType, "interfaceType");

            var interfaceTypeSyntax = this.GetTypeNameSyntax(interfaceType);
            string className = GetClassNameForMetadataView(interfaceType);
            var metadataDictionary = SyntaxFactory.IdentifierName("metadata");

            var view = SyntaxFactory.ClassDeclaration(className)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword))
                .WithBaseList(SyntaxFactory.BaseList(SyntaxFactory.SingletonSeparatedList(interfaceTypeSyntax)))
                .AddMembers(
                    SyntaxFactory.FieldDeclaration(SyntaxFactory.VariableDeclaration(
                        readonlyDictionaryOfStringObjectSyntax,
                        SyntaxFactory.SingletonSeparatedList(SyntaxFactory.VariableDeclarator(metadataDictionary.Identifier))))
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword), SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword)),
                    SyntaxFactory.ConstructorDeclaration(className)
                        .AddParameterListParameters(SyntaxFactory.Parameter(metadataDictionary.Identifier).WithType(readonlyDictionaryOfStringObjectSyntax))
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.InternalKeyword))
                        .WithBody(SyntaxFactory.Block(
                            SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    SyntaxFactory.ThisExpression(),
                                    metadataDictionary),
                                metadataDictionary)))))
                .AddMembers(
                    interfaceType.EnumProperties().WherePublicInstance().Select(member =>
                        SyntaxFactory.PropertyDeclaration(this.GetTypeNameSyntax(ReflectionHelpers.GetMemberType(member)), member.Name)
                            .WithExplicitInterfaceSpecifier(SyntaxFactory.ExplicitInterfaceSpecifier(SyntaxFactory.ParseName(member.DeclaringType.FullName.Replace('+', '.'))))
                            .AddAccessorListAccessors(
                                SyntaxFactory.AccessorDeclaration(
                                    SyntaxKind.GetAccessorDeclaration,
                                    SyntaxFactory.Block(
                                        SyntaxFactory.ReturnStatement(GetValueOrDefaultForMetadataView(member, metadataDictionary, SyntaxFactory.ThisExpression())))))
                        ).ToArray());

            return view;
        }

        private StatementSyntax CreateMemberAssignment(ImportDefinitionBinding import, ExpressionSyntax value, IdentifierNameSyntax partInstanceVar, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(import, "import");
            Requires.NotNull(value, "value");

            StatementSyntax statement;
            if (IsPublic(import.ImportingMember, import.ComposablePartType, setter: true))
            {
                // result.Property = value;
                statement = SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, partInstanceVar, SyntaxFactory.IdentifierName(import.ImportingMember.Name)),
                    value));
            }
            else
            {
                ExpressionSyntax expression;
                var importingField = import.ImportingMember as FieldInfo;
                var importingProperty = import.ImportingMember as PropertyInfo;
                Assumes.True(importingField != null || importingProperty != null);

                if (importingField != null)
                {
                    // fieldInfo.SetValue(result, value);
                    expression = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, this.GetFieldInfoExpressionSyntax(importingField, thisExportProvider), SyntaxFactory.IdentifierName("SetValue")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(partInstanceVar),
                            SyntaxFactory.Argument(value))));
                }
                else // property
                {
                    // propertyInfo.SetValue(result, value);
                    expression = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, this.GetMethodInfoExpression(importingProperty.GetSetMethod(true), thisExportProvider), SyntaxFactory.IdentifierName("Invoke")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(partInstanceVar),
                            GetObjectArrayArgument(value))));
                }

                return SyntaxFactory.ExpressionStatement(expression);
            }

            return statement;
        }

        private ExpressionSyntax CreateMemberRetrieval(MemberInfo member, ExpressionSyntax declaringTypeInstance, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(member, "member");
            Requires.NotNull(declaringTypeInstance, "declaringTypeInstance");

            var type = member as Type;
            if (type != null)
            {
                // The member is the type itself.
                return declaringTypeInstance;
            }

            bool isStatic = member.IsStatic();
            if (IsPublic(member, member.DeclaringType))
            {
                // Cast to make sure we succeed even if the member is an explicit interface implementation.
                var typeOrInstance = isStatic
                    ? (ExpressionSyntax)this.GetTypeNameSyntax(member.DeclaringType)
                    : SyntaxFactory.ParenthesizedExpression(SyntaxFactory.CastExpression(
                        this.GetTypeNameSyntax(member.DeclaringType),
                        declaringTypeInstance));
                return SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    typeOrInstance,
                    SyntaxFactory.IdentifierName(member.Name));
            }

            var field = member as FieldInfo;
            if (field != null)
            {
                // fieldInfo.GetValue(instance)
                return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        this.GetFieldInfoExpressionSyntax(field, thisExportProvider),
                        SyntaxFactory.IdentifierName("GetValue")),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                        isStatic ? NullSyntax : declaringTypeInstance))));
            }

            var property = member as PropertyInfo;
            if (property != null)
            {
                return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        GetMethodInfoExpression(property.GetGetMethod(true), thisExportProvider),
                        SyntaxFactory.IdentifierName("Invoke")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(isStatic ? NullSyntax : declaringTypeInstance),
                        GetObjectArrayArgument())));
            }

            var method = member as MethodInfo;
            if (method != null)
            {
                return this.GetMethodInfoExpression(method, thisExportProvider);
            }

            throw new NotSupportedException();
        }

        private ExpressionSyntax GetFieldInfoExpressionSyntax(FieldInfo fieldInfo, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(fieldInfo, "fieldInfo");

            if (fieldInfo.DeclaringType.IsGenericType)
            {
                return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        this.GetClosedGenericTypeExpression(fieldInfo.DeclaringType, thisExportProvider),
                        SyntaxFactory.IdentifierName("GetField")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(fieldInfo.Name))),
                        SyntaxFactory.Argument(SyntaxFactory.BinaryExpression(
                            SyntaxKind.BitwiseOrExpression,
                            SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, SyntaxFactory.IdentifierName("BindingFlags"), SyntaxFactory.IdentifierName("Instance")),
                            SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, SyntaxFactory.IdentifierName("BindingFlags"), SyntaxFactory.IdentifierName("NonPublic")))))));
            }
            else
            {
                return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        this.GetManifestModuleSyntax(fieldInfo.DeclaringType.Assembly, thisExportProvider),
                        SyntaxFactory.IdentifierName("ResolveField")),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                        SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(fieldInfo.MetadataToken))
                            .WithTrailingTrivia(SyntaxFactory.Comment("/*" + GetTypeName(fieldInfo.DeclaringType, evenNonPublic: true) + "." + fieldInfo.Name + "*/"))))));
            }
        }

        /// <summary>
        /// Gets syntax that will reconstruct the MemberInfo for a given member.
        /// </summary>
        /// <param name="member">A field or method. If a property, either the getter or the setter will be retrieved.</param>
        /// <param name="favorPropertySetter"><c>true</c> to create syntax to reconstruct the property setter method; <c>false</c> to reconstruct the getter method.</param>
        /// <returns>The reconstruction syntax.</returns>
        private ExpressionSyntax GetMemberInfoSyntax(MemberInfo member, ExpressionSyntax thisExportProvider, bool favorPropertySetter = false)
        {
            Requires.NotNull(member, "member");

            var property = member as PropertyInfo;
            if (property != null)
            {
                member = favorPropertySetter ? property.GetSetMethod(true) : property.GetGetMethod(true);
            }

            IdentifierNameSyntax infoClass, memberHandle, getMemberFromHandle, resolveMember;
            switch (member.MemberType)
            {
                case MemberTypes.Field:
                    infoClass = SyntaxFactory.IdentifierName("FieldInfo");
                    memberHandle = SyntaxFactory.IdentifierName("FieldHandle");
                    getMemberFromHandle = SyntaxFactory.IdentifierName("GetFieldFromHandle");
                    resolveMember = SyntaxFactory.IdentifierName("ResolveField");
                    break;
                case MemberTypes.Method:
                    infoClass = SyntaxFactory.IdentifierName("MethodInfo");
                    memberHandle = SyntaxFactory.IdentifierName("MethodHandle");
                    getMemberFromHandle = SyntaxFactory.IdentifierName("GetMethodFromHandle");
                    resolveMember = SyntaxFactory.IdentifierName("ResolveMethod");
                    break;
                default:
                    throw new NotSupportedException();
            }

            // manifest.ResolveMember(metadataToken/*description*/)
            var resolveMemberInvocation = SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    this.GetManifestModuleSyntax(member.DeclaringType.Assembly, thisExportProvider),
                    resolveMember),
                SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                    SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(member.MetadataToken))
                        .WithTrailingTrivia(SyntaxFactory.Comment("/*" + GetTypeName(member.DeclaringType, evenNonPublic: true) + "." + member.Name + "*/"))))));

            ExpressionSyntax memberInfoSyntax;
            if (member.DeclaringType.IsGenericType)
            {
                // MethodInfo.GetMethodFromHandle({0}.ResolveMethod({1}/*{3}*/).MethodHandle, {2})
                memberInfoSyntax = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, infoClass, getMemberFromHandle),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, resolveMemberInvocation, memberHandle)),
                        SyntaxFactory.Argument(this.GetClosedGenericTypeHandleExpression(member.DeclaringType, thisExportProvider)))));
            }
            else
            {
                memberInfoSyntax = resolveMemberInvocation;
            }

            var castExpression = SyntaxFactory.ParenthesizedExpression(
                SyntaxFactory.CastExpression(infoClass, memberInfoSyntax));
            return castExpression;
        }

        private ExpressionSyntax GetMethodInfoExpression(MethodInfo methodInfo, ExpressionSyntax thisExportProvider)
        {
            return this.GetMemberInfoSyntax(methodInfo, thisExportProvider);
        }

        private ExpressionSyntax GetClosedGenericTypeExpression(Type type, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(type, "type");

            // {0}.ResolveType({1}/*{3}*/).MakeGenericType({2})
            return SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            this.GetManifestModuleSyntax(type.Assembly, thisExportProvider),
                            SyntaxFactory.IdentifierName("ResolveType")),
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                            SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(type.GetGenericTypeDefinition().MetadataToken)))
                                .WithTrailingTrivia(SyntaxFactory.Comment("/*" + (type.ContainsGenericParameters ? "incomplete" : this.GetTypeName(type, evenNonPublic: true)) + "*/"))))),
                    SyntaxFactory.IdentifierName("MakeGenericType")),
                SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                    SyntaxKind.CommaToken,
                    type.GetGenericArguments().Select(t => SyntaxFactory.Argument(t.IsGenericType && t.ContainsGenericParameters ? GetClosedGenericTypeExpression(t, thisExportProvider) : GetTypeExpressionSyntax(t, thisExportProvider))).ToArray())));
        }

        private ExpressionSyntax GetClosedGenericTypeHandleExpression(Type type, ExpressionSyntax thisExportProvider)
        {
            return SyntaxFactory.MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                GetClosedGenericTypeExpression(type, thisExportProvider),
                SyntaxFactory.IdentifierName("TypeHandle"));
        }

        private StatementSyntax[] GetImportSatisfyingAssignmentSyntax(KeyValuePair<ImportDefinitionBinding, IReadOnlyList<ExportDefinitionBinding>> satisfyingExport, ExpressionSyntax provisionalSharedObjects, ExpressionSyntax thisExportProvider)
        {
            Requires.Argument(satisfyingExport.Key.ImportingMember != null, "satisfyingExport", "No member to satisfy.");
            Requires.NotNull(provisionalSharedObjects, "provisionalSharedObjects");
            Requires.NotNull(thisExportProvider, "thisExportProvider");

            var import = satisfyingExport.Key;
            var importingMember = satisfyingExport.Key.ImportingMember;
            var exports = satisfyingExport.Value;
            var partInstanceVar = SyntaxFactory.IdentifierName(InstantiatedPartLocalVarName);

            IReadOnlyList<StatementSyntax> prereqs;
            var expression = GetImportSatisfyingExpression(import, exports, provisionalSharedObjects, thisExportProvider, out prereqs);
            var statements = new List<StatementSyntax>(prereqs);
            statements.Add(CreateMemberAssignment(import, expression, partInstanceVar, thisExportProvider));
            return statements.ToArray();
        }

        private ExpressionSyntax GetImportSatisfyingExpression(ImportDefinitionBinding import, IReadOnlyList<ExportDefinitionBinding> exports, ExpressionSyntax provisionalSharedObjects, ExpressionSyntax thisExportProvider, out IReadOnlyList<StatementSyntax> prerequisiteStatements)
        {
            Requires.NotNull(import, "import");
            Requires.NotNull(exports, "exports");
            Requires.NotNull(provisionalSharedObjects, "provisionalSharedObjects");
            Requires.NotNull(thisExportProvider, "thisExportProvider");

            if (import.ImportDefinition.Cardinality == ImportCardinality.ZeroOrMore)
            {
                Type enumerableOfTType = typeof(IEnumerable<>).MakeGenericType(import.ImportingSiteTypeWithoutCollection);
                if (import.ImportingSiteType.IsArray || import.ImportingSiteType.IsEquivalentTo(enumerableOfTType))
                {
                    return this.GetSatisfyImportManyArrayExpression(import, exports, provisionalSharedObjects, thisExportProvider, out prerequisiteStatements);
                }
                else
                {
                    return this.GetSatisfyImportManyCollectionExpression(import, exports, provisionalSharedObjects, thisExportProvider, out prerequisiteStatements);
                }
            }
            else if (exports.Any())
            {
                prerequisiteStatements = ImmutableList<StatementSyntax>.Empty;
                return this.GetImportAssignableValueForExport(import, exports.Single(), provisionalSharedObjects, thisExportProvider);
            }
            else
            {
                prerequisiteStatements = ImmutableList<StatementSyntax>.Empty;
                if (IsPublic(import.ImportingSiteType))
                {
                    return SyntaxFactory.DefaultExpression(this.GetTypeNameSyntax(import.ImportingSiteType));
                }
                else if (import.ImportingSiteType.IsValueType)
                {
                    // It's a non-public struct. We have to construct its default value by hand.
                    return SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName("Activator"),
                            SyntaxFactory.IdentifierName("CreateInstance")),
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(GetTypeExpressionSyntax(import.ImportingSiteType, thisExportProvider)))));
                }
                else
                {
                    return SyntaxFactory.CastExpression(
                        this.GetTypeNameSyntax(import.ImportingSiteType),
                        SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression));
                }
            }
        }

        private ExpressionSyntax GetSatisfyImportManyArrayExpression(ImportDefinitionBinding import, IEnumerable<ExportDefinitionBinding> exports, ExpressionSyntax provisionalSharedObjects, ExpressionSyntax thisExportProvider, out IReadOnlyList<StatementSyntax> prerequisiteStatements)
        {
            Requires.NotNull(import, "import");
            Requires.NotNull(exports, "exports");
            Requires.NotNull(provisionalSharedObjects, "provisionalSharedObjects");

            var prereqs = new List<StatementSyntax>();
            prerequisiteStatements = prereqs;

            if (IsPublic(import.ImportingSiteType, true))
            {
                var arrayType = SyntaxFactory.ArrayType(
                    this.GetTypeNameSyntax(import.ImportingSiteTypeWithoutCollection),
                    SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>(
                        SyntaxFactory.ArrayRankSpecifier(
                            SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(SyntaxFactory.OmittedArraySizeExpression()))));
                return SyntaxFactory.ArrayCreationExpression(
                    arrayType,
                    SyntaxFactory.InitializerExpression(
                    SyntaxKind.ArrayInitializerExpression,
                    CodeGen.JoinSyntaxNodes<ExpressionSyntax>(
                        SyntaxKind.CommaToken,
                        exports.Select(export => this.GetImportAssignableValueForExport(import, export, provisionalSharedObjects, thisExportProvider)).ToArray())));
            }
            else
            {
                // This will require a multi-statement construction of the array.
                // var localVarName = Array.CreateInstance(typeof(...), exports.Count);
                var localVar = SyntaxFactory.IdentifierName(ReserveLocalVarName(import.ImportingMember != null ? import.ImportingMember.Name : "tmp"));
                prereqs.Add(SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(SyntaxFactory.IdentifierName("var"))
                        .AddVariables(SyntaxFactory.VariableDeclarator(localVar.Identifier)
                            .WithInitializer(SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName("Array"),
                                        SyntaxFactory.IdentifierName("CreateInstance")),
                                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                                        SyntaxKind.CommaToken,
                                        SyntaxFactory.Argument(this.GetTypeExpressionSyntax(import.ImportingSiteTypeWithoutCollection, thisExportProvider)),
                                        SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(exports.Count())))))))))));
                int arrayIndex = 0;
                foreach (var export in exports)
                {
                    prereqs.Add(SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            localVar,
                            SyntaxFactory.IdentifierName("SetValue")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(this.GetImportAssignableValueForExport(import, export, provisionalSharedObjects, thisExportProvider)),
                            SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(arrayIndex++))))))));
                }

                return localVar;
            }
        }

        private ExpressionSyntax GetSatisfyImportManyCollectionExpression(ImportDefinitionBinding import, IReadOnlyList<ExportDefinitionBinding> exports, ExpressionSyntax provisionalSharedObjects, ExpressionSyntax thisExportProvider, out IReadOnlyList<StatementSyntax> prerequisiteStatements)
        {
            Requires.NotNull(import, "import");
            Requires.NotNull(exports, "exports");
            Requires.NotNull(provisionalSharedObjects, "provisionalSharedObjects");

            var importDefinition = import.ImportDefinition;
            Type elementType = import.ImportingSiteTypeWithoutCollection;
            Type listType = typeof(List<>).MakeGenericType(elementType);
            bool stronglyTypedCollection = IsPublic(elementType, true);
            Type icollectionType = typeof(ICollection<>).MakeGenericType(elementType);
            var importManyLocalVarType = stronglyTypedCollection ? GetTypeNameSyntax(icollectionType) : SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword));
            var tempVar = SyntaxFactory.IdentifierName(ReserveLocalVarName(import.ImportingMember.Name));
            var instantiatedPartLocalVar = SyntaxFactory.IdentifierName(InstantiatedPartLocalVarName);

            var prereqs = new List<StatementSyntax>();
            prerequisiteStatements = prereqs;

            // Casting the collection to ICollection<T> instead of the concrete type guarantees
            // that we'll be able to call Add(T) and Clear() on it even if the type is NonPublic
            // or its methods are explicit interface implementations.
            ExpressionSyntax tempVarAssignedValue;
            if (import.ImportingMember is FieldInfo)
            {
                // fieldInfo.GetValue(result);
                tempVarAssignedValue = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        this.GetFieldInfoExpressionSyntax((FieldInfo)import.ImportingMember, thisExportProvider),
                        SyntaxFactory.IdentifierName("GetValue")),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(instantiatedPartLocalVar))));
            }
            else
            {
                // methodInfo.Invoke(result, new object[0])
                tempVarAssignedValue = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        GetMethodInfoExpression(((PropertyInfo)import.ImportingMember).GetGetMethod(true), thisExportProvider),
                        SyntaxFactory.IdentifierName("Invoke")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(instantiatedPartLocalVar),
                        GetObjectArrayArgument())));
            }

            // var tempVar = (ICollection<T>)...
            prereqs.Add(SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(
                    SyntaxFactory.IdentifierName("var"),
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.VariableDeclarator(tempVar.Identifier)
                            .WithInitializer(SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.CastExpression(importManyLocalVarType, tempVarAssignedValue)))))));

            var initBlock = SyntaxFactory.Block();
            var clearBlock = SyntaxFactory.Block();

            // if (tempVar == null)
            {
                if (PartDiscovery.IsImportManyCollectionTypeCreateable(import))
                {
                    ConstructorInfo collectionCtor;
                    if (import.ImportingSiteType.IsAssignableFrom(listType))
                    {
                        collectionCtor = typeof(List<>).MakeGenericType(elementType).GetConstructor(new Type[0]);
                    }
                    else
                    {
                        collectionCtor = import.ImportingSiteType.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[0], null);
                    }

                    initBlock = initBlock.AddStatements(
                        // tempVar = new List<T>();
                        SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            tempVar,
                            SyntaxFactory.CastExpression(
                                importManyLocalVarType,
                                this.ObjectCreationExpression(collectionCtor, new ExpressionSyntax[0], thisExportProvider)))),

                        // result.Member = tempVar
                        this.CreateMemberAssignment(
                            import,
                            SyntaxFactory.CastExpression(this.GetTypeNameSyntax(import.ImportingSiteType), tempVar),
                            instantiatedPartLocalVar,
                            thisExportProvider));
                }
                else
                {
                    initBlock = initBlock.AddStatements(
                        SyntaxFactory.ThrowStatement(
                            SyntaxFactory.ObjectCreationExpression(
                                SyntaxFactory.IdentifierName("InvalidOperationException"),
                                SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    SyntaxFactory.Literal(string.Format(
                                        CultureInfo.InvariantCulture,
                                        "throw new InvalidOperationException(\"The {0}.{1} collection must be instantiated by the importing constructor.\");",
                                        import.ComposablePartType.Name,
                                        import.ImportingMember.Name)))))),
                                null)));
                }
            }

            // else tempVar != null
            {
                InvocationExpressionSyntax clearInvocation;
                if (stronglyTypedCollection)
                {
                    // tempVar.Clear();
                    clearInvocation = SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, tempVar, SyntaxFactory.IdentifierName("Clear")),
                            SyntaxFactory.ArgumentList());
                }
                else
                {
                    // clearMethodInfo.Invoke(tempVar, new object[0])
                    clearInvocation = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            GetMethodInfoExpression(icollectionType.GetMethod("Clear"), thisExportProvider),
                            SyntaxFactory.IdentifierName("Invoke")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(tempVar),
                            GetObjectArrayArgument())));
                }

                clearBlock = clearBlock.AddStatements(SyntaxFactory.ExpressionStatement(clearInvocation));
            }

            prereqs.Add(SyntaxFactory.IfStatement(
                SyntaxFactory.BinaryExpression(SyntaxKind.EqualsExpression, tempVar, SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
                initBlock,
                SyntaxFactory.ElseClause(clearBlock)));

            foreach (var export in exports)
            {
                InvocationExpressionSyntax addExpression;
                var exportValue = this.GetImportAssignableValueForExport(import, export, provisionalSharedObjects, thisExportProvider);
                if (stronglyTypedCollection)
                {
                    // tempVar.Add(export);
                    addExpression = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, tempVar, SyntaxFactory.IdentifierName("Add")),
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(exportValue))));
                }
                else
                {
                    // addMethodInfo.Invoke(tempVar, new object[] { export })
                    addExpression = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, GetMethodInfoExpression(icollectionType.GetMethod("Add"), thisExportProvider), SyntaxFactory.IdentifierName("Invoke")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(tempVar),
                            GetObjectArrayArgument(exportValue))));
                }

                prereqs.Add(SyntaxFactory.ExpressionStatement(addExpression));
            }

            // (TCollection)tempVar
            var castExpression = SyntaxFactory.CastExpression(
                this.GetTypeNameSyntax(import.ImportingSiteType),
                tempVar);

            return castExpression;
        }

        private ExpressionSyntax GetExportMetadata(ExportDefinitionBinding export, ExpressionSyntax thisExportProvider)
        {
            return this.GetSyntaxToReconstructMetadata(export.ExportDefinition.Metadata, thisExportProvider);
        }

        private ExpressionSyntax GetSyntaxToReconstructMetadata(IReadOnlyDictionary<string, object> value, ExpressionSyntax thisExportProvider)
        {
            if (value == null)
            {
                return GetSyntaxToReconstructValue((object)null, thisExportProvider);
            }

            ExpressionSyntax populatingExpression = SyntaxFactory.IdentifierName("EmptyMetadata");
            bool substitutionRequiredByAnyValue = false;
            foreach (var pair in value)
            {
                bool substitutionRequired;
                populatingExpression = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        populatingExpression,
                        SyntaxFactory.IdentifierName("Add")),
                        SyntaxFactory.ArgumentList(
                            SyntaxFactory.SeparatedList<ArgumentSyntax>(new ArgumentSyntax[] {
                                SyntaxFactory.Argument(GetSyntaxToReconstructValue(pair.Key, thisExportProvider)),
                                SyntaxFactory.Argument(GetSyntaxToReconstructValueWithTypeRefSubstitution(pair.Value, thisExportProvider, out substitutionRequired)),
                            })));
                substitutionRequiredByAnyValue |= substitutionRequired;
            }

            if (substitutionRequiredByAnyValue)
            {
                // this.GetTypeRefResolvingMetadata(...)
                var lazyResolvingExpression = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        thisExportProvider,
                        SyntaxFactory.IdentifierName("GetTypeRefResolvingMetadata")),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(populatingExpression))));
                return lazyResolvingExpression;
            }
            else
            {
                return populatingExpression;
            }
        }

        private ExpressionSyntax GetSyntaxToReconstructValueWithTypeRefSubstitution(object value, ExpressionSyntax thisExportProvider, out bool substitutionRequired)
        {
            if (value is Type)
            {
                substitutionRequired = true;

                // new TypeRef(15)
                return SyntaxFactory.ObjectCreationExpression(
                    SyntaxFactory.IdentifierName("TypeRef"),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(this.GetTypeIdSyntax((Type)value)))),
                    null);
            }
            else if (value is Type[])
            {
                var valueAsTypeArray = (Type[])value;
                substitutionRequired = true;
                var typeRefs = new ExpressionSyntax[valueAsTypeArray.Length];
                for (int i = 0; i < valueAsTypeArray.Length; i++)
                {
                    typeRefs[i] = GetSyntaxToReconstructValueWithTypeRefSubstitution(valueAsTypeArray[i], thisExportProvider, out substitutionRequired);
                }

                // new TypeRef[] { new TypeRef(15), new TypeRef(18) }
                return SyntaxFactory.ArrayCreationExpression(
                    SyntaxFactory.ArrayType(SyntaxFactory.IdentifierName("TypeRef"))
                        .WithRankSpecifiers(
                            SyntaxFactory.SingletonList(
                            SyntaxFactory.ArrayRankSpecifier(
                                SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                    SyntaxFactory.OmittedArraySizeExpression())))),
                    SyntaxFactory.InitializerExpression(
                        SyntaxKind.ArrayInitializerExpression,
                        SyntaxFactory.SeparatedList<ExpressionSyntax>(typeRefs)))
                    .WithNewKeywordTrivia();
            }
            else
            {
                substitutionRequired = false;
                return this.GetSyntaxToReconstructValue(value, thisExportProvider);
            }
        }

        private ExpressionSyntax GetSyntaxToReconstructValue(object value, ExpressionSyntax thisExportProvider)
        {
            if (value == null)
            {
                return SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression);
            }

            Type valueType = value.GetType();
            if (value is string)
            {
                return SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal((string)value));
            }
            else if (typeof(char).IsEquivalentTo(valueType))
            {
                return SyntaxFactory.LiteralExpression(SyntaxKind.CharacterLiteralExpression, SyntaxFactory.Literal((char)value));
            }
            else if (typeof(bool).IsEquivalentTo(valueType))
            {
                return (bool)value
                    ? SyntaxFactory.LiteralExpression(SyntaxKind.TrueLiteralExpression)
                    : SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression);
            }
            else if (valueType.IsEquivalentTo(typeof(double)) && (double)value == double.MaxValue)
            {
                return SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.DoubleKeyword)),
                    SyntaxFactory.IdentifierName("MaxValue"));
            }
            else if (valueType.IsEquivalentTo(typeof(double)) && (double)value == double.MinValue)
            {
                return SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.DoubleKeyword)),
                    SyntaxFactory.IdentifierName("MinValue"));
            }
            else if (valueType.IsEquivalentTo(typeof(float)) && (float)value == float.MaxValue)
            {
                return SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.FloatKeyword)),
                    SyntaxFactory.IdentifierName("MaxValue"));
            }
            else if (valueType.IsEquivalentTo(typeof(float)) && (float)value == float.MinValue)
            {
                return SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.FloatKeyword)),
                    SyntaxFactory.IdentifierName("MinValue"));
            }
            else if (valueType.IsEquivalentTo(typeof(int)))
            {
                return SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal((int)value));
            }
            else if (valueType.IsPrimitive)
            {
                return SyntaxFactory.CastExpression(
                    SyntaxFactory.ParseTypeName(GetTypeName(valueType)),
                    SyntaxFactory.ParenthesizedExpression(SyntaxFactory.ParseExpression(value.ToString())));
            }
            else if (valueType.IsEquivalentTo(typeof(Guid)))
            {
                return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName("Guid"),
                        SyntaxFactory.IdentifierName("Parse")),
                    SyntaxFactory.ArgumentList(
                        SyntaxFactory.SingletonSeparatedList(
                            SyntaxFactory.Argument(
                                SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(((Guid)value).ToString()))))));
            }
            else if (valueType.IsEnum)
            {
                ExpressionSyntax underlyingTypeValue = GetSyntaxToReconstructValue(Convert.ChangeType(value, Enum.GetUnderlyingType(valueType)), thisExportProvider);
                if (IsPublic(valueType, true))
                {
                    return SyntaxFactory.CastExpression(GetTypeNameSyntax(valueType), underlyingTypeValue);
                }
                else
                {
                    return SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName("Enum"),
                            SyntaxFactory.IdentifierName("ToObject")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes<ArgumentSyntax>(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(GetTypeExpressionSyntax(valueType, thisExportProvider)),
                            SyntaxFactory.Argument(underlyingTypeValue))));
                }
            }
            else if (typeof(Type).IsAssignableFrom(valueType))
            {
                // assumeNonPublic=true because typeof() would result in the JIT compiler
                // loading the assembly containing the type itself even before this
                // part is activated.
                return SyntaxFactory.CastExpression(
                    GetTypeNameSyntax(valueType), // Cast as TypeInfo to avoid some compilation errors.
                    SyntaxFactory.ParseExpression(GetTypeExpression((Type)value, thisExportProvider, assumeNonPublic: true)));
            }
            else if (valueType.IsArray)
            {
                var array = (Array)value;
                return SyntaxFactory.ArrayCreationExpression(
                    SyntaxFactory.ArrayType(GetTypeNameSyntax(valueType.GetElementType()))
                        .WithRankSpecifiers(
                            SyntaxFactory.SingletonList(
                            SyntaxFactory.ArrayRankSpecifier(
                                SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                    SyntaxFactory.OmittedArraySizeExpression())))),
                    SyntaxFactory.InitializerExpression(
                        SyntaxKind.ArrayInitializerExpression,
                        SyntaxFactory.SeparatedList<ExpressionSyntax>(
                            array.Cast<object>().Select(v => GetSyntaxToReconstructValue(v, thisExportProvider)))))
                    .WithNewKeywordTrivia();
            }

            throw new NotSupportedException();
        }

        private TypeSyntax GetTypeNameSyntax(Type type, bool genericTypeDefinition = false, bool evenNonPublic = false)
        {
            Requires.NotNull(type, "type");

            if (type.IsEquivalentTo(typeof(string)))
            {
                return SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword));
            }
            else if (type.IsEquivalentTo(typeof(object)))
            {
                return SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword));
            }

            return SyntaxFactory.ParseTypeName(this.GetTypeName(type, genericTypeDefinition, evenNonPublic));
        }

        private ExpressionSyntax ObjectCreationExpression(ComposablePartDefinition partDefinition, ExpressionSyntax[] arguments, ExpressionSyntax thisExportProvider, bool alwaysUseReflection = false)
        {
            Requires.NotNull(partDefinition, "partDefinition");
            return this.ObjectCreationExpression(partDefinition.ImportingConstructorInfo, arguments, thisExportProvider, alwaysUseReflection);
        }

        private ExpressionSyntax ObjectCreationExpression(ConstructorInfo ctor, ExpressionSyntax[] arguments, ExpressionSyntax thisExportProvider, bool alwaysUseReflection = false)
        {
            Requires.NotNull(ctor, "ctor");
            Requires.NotNull(arguments, "arguments");

            bool publicCtor = !alwaysUseReflection && IsPublic(ctor, ctor.DeclaringType);
            if (publicCtor)
            {
                return SyntaxFactory.ObjectCreationExpression(
                    this.GetTypeNameSyntax(ctor.DeclaringType),
                    SyntaxFactory.ArgumentList(
                        CodeGen.JoinSyntaxNodes<ArgumentSyntax>(
                            SyntaxKind.CommaToken,
                            arguments.Select(SyntaxFactory.Argument).ToArray())),
                    null);
            }
            else
            {
                var manifestModuleSyntax = this.GetManifestModuleSyntax(ctor.DeclaringType.Assembly, thisExportProvider);
                var typeName = GetTypeNameSyntax(ctor.DeclaringType, evenNonPublic: true).ToString() + "." + ctor.Name;

                // manifestModule.ResolveMethod(ctorMetadataToken/*typeName.ctor*/)
                var resolveMethodSyntax = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        manifestModuleSyntax,
                        SyntaxFactory.IdentifierName("ResolveMethod")),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                        SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(ctor.MetadataToken))
                        .WithTrailingTrivia(SyntaxFactory.Comment("/*" + typeName + "*/"))))));

                ExpressionSyntax ctorSyntax;
                if (ctor.DeclaringType.IsGenericType)
                {
                    // "(ConstructorInfo)MethodInfo.GetMethodFromHandle({2}.ResolveMethod({0}/*{3}*/).MethodHandle, {1})"
                    ctorSyntax = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName("MethodInfo"),
                            SyntaxFactory.IdentifierName("GetMethodFromHandle")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes<ArgumentSyntax>(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(
                                SyntaxFactory.MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    resolveMethodSyntax,
                                    SyntaxFactory.IdentifierName("MethodHandle"))),
                            SyntaxFactory.Argument(this.GetClosedGenericTypeHandleExpression(ctor.DeclaringType, thisExportProvider)))));
                }
                else
                {
                    // (ConstructorInfo){0}.ResolveMethod({1}/*{2}*/) 
                    ctorSyntax = resolveMethodSyntax;
                }

                ctorSyntax = SyntaxFactory.ParenthesizedExpression(SyntaxFactory.CastExpression(
                    SyntaxFactory.IdentifierName("ConstructorInfo"),
                    ctorSyntax));

                // (Type)ctor.Invoke(new object[] { ... })
                var invokeArg = GetObjectArrayArgument(arguments);
                var invokeExpression = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ctorSyntax,
                        SyntaxFactory.IdentifierName("Invoke")),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(invokeArg)));
                var castExpression = SyntaxFactory.CastExpression(
                    this.GetTypeNameSyntax(ctor.DeclaringType),
                    invokeExpression);
                return castExpression;
            }
        }

        /// <summary>
        /// Creates a <c>new object[] { arg1, arg2 }</c> style syntax for a list of arguments.
        /// </summary>
        /// <param name="arguments">The list of arguments to format as an object array.</param>
        /// <returns>The object[] creation syntax.</returns>
        private static ArgumentSyntax GetObjectArrayArgument(params ExpressionSyntax[] arguments)
        {
            if (arguments.Length == 0)
            {
                return SyntaxFactory.Argument(SyntaxFactory.IdentifierName("EmptyObjectArray"));
            }
            else
            {
                return SyntaxFactory.Argument(SyntaxFactory.ArrayCreationExpression(
                    SyntaxFactory.ArrayType(
                        SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword)),
                        SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>(
                            SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(SyntaxFactory.OmittedArraySizeExpression())))),
                    SyntaxFactory.InitializerExpression(
                        SyntaxKind.ArrayInitializerExpression,
                        CodeGen.JoinSyntaxNodes(SyntaxKind.CommaToken, arguments))));
            }
        }

        private MethodDeclarationSyntax CreateInstantiatePartMethod(ComposedPart part)
        {
            var provisionalSharedObjectsIdentifier = SyntaxFactory.IdentifierName("provisionalSharedObjects");
            var partInstanceIdentifier = SyntaxFactory.IdentifierName(InstantiatedPartLocalVarName);
            var thisExportProviderIdentifier = SyntaxFactory.IdentifierName("that");
            var thisExportProvider = SyntaxFactory.ParenthesizedExpression(SyntaxFactory.CastExpression(
                 SyntaxFactory.IdentifierName(CompiledExportProviderTypeName),
                 thisExportProviderIdentifier));

            var method = SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword)),
                GetPartFactoryMethodNameNoTypeArgs(part.Definition))
                .WithTypeParameterList(part.Definition.Type.IsGenericType ? SyntaxFactory.TypeParameterList(CodeGen.JoinSyntaxNodes(
                    SyntaxKind.CommaToken,
                    part.Definition.Type.GetGenericArguments().Select(t => SyntaxFactory.TypeParameter(t.Name)).ToArray())) : null)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.InternalKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(thisExportProviderIdentifier.Identifier).WithType(SyntaxFactory.IdentifierName("ExportProvider")),
                    SyntaxFactory.Parameter(provisionalSharedObjectsIdentifier.Identifier).WithType(dictionaryOfIntObject));

            var statements = new List<StatementSyntax>();
            if (part.Definition.IsInstantiable)
            {
                // TPart result;
                statements.Add(SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        this.GetTypeNameSyntax(part.Definition.Type),
                        SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>(
                            SyntaxFactory.VariableDeclarator(partInstanceIdentifier.Identifier)))));

                var localSymbols = new HashSet<string>();
                var block = SyntaxFactory.Block();
                int importingConstructorArgIndex = 0;
                var importingConstructorArgNames = new string[part.Definition.ImportingConstructor.Count];
                foreach (var pair in part.GetImportingConstructorImports())
                {
                    IReadOnlyList<StatementSyntax> prereqStatements;
                    var importSatisfyingExpression = this.GetImportSatisfyingExpression(pair.Key, pair.Value, provisionalSharedObjectsIdentifier, thisExportProvider, out prereqStatements);
                    if (prereqStatements.Count > 0)
                    {
                        block = block.AddStatements(prereqStatements.ToArray());
                    }

                    block = block.AddStatements(SyntaxFactory.LocalDeclarationStatement(
                        SyntaxFactory.VariableDeclaration(
                            SyntaxFactory.IdentifierName("var"),
                            SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>(
                                SyntaxFactory.VariableDeclarator(
                                    importingConstructorArgNames[importingConstructorArgIndex++] = ReserveLocalVarName("arg", localSymbols))
                                    .WithInitializer(SyntaxFactory.EqualsValueClause(
                                        importSatisfyingExpression))))));
                }

                block = block.AddStatements(SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        partInstanceIdentifier,
                        this.ObjectCreationExpression(part.Definition, importingConstructorArgNames.Select(SyntaxFactory.IdentifierName).ToArray(), thisExportProvider))));

                statements.Add(block);

                if (typeof(IDisposable).IsAssignableFrom(part.Definition.Type))
                {
                    // this.TrackDisposableValue((IDisposable)result);
                    statements.Add(SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            thisExportProvider,
                            SyntaxFactory.IdentifierName("TrackDisposableValue")),
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                            SyntaxFactory.CastExpression(
                                SyntaxFactory.IdentifierName("IDisposable"),
                                partInstanceIdentifier)))))));
                }

                if (part.Definition.IsShared)
                {
                    // Getting the typeId for this part takes extra care if it's a generic type since
                    // we only know it's final type at runtime.
                    ExpressionSyntax partTypeSyntax = part.Definition.Type.IsGenericType
                        ? (ExpressionSyntax)SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                thisExportProvider,
                                SyntaxFactory.IdentifierName("GetTypeId")),
                            SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                                partInstanceIdentifier))))
                        : this.GetTypeIdSyntax(part.Definition.Type);

                    // provisionalSharedObjects.Add(partTypeId, result);
                    statements.Add(SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            provisionalSharedObjectsIdentifier,
                            SyntaxFactory.IdentifierName("Add")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                            SyntaxKind.CommaToken,
                            SyntaxFactory.Argument(partTypeSyntax),
                            SyntaxFactory.Argument(partInstanceIdentifier))))));
                }

                foreach (var satisfyingExport in part.SatisfyingExports.Where(i => i.Key.ImportingMember != null))
                {
                    statements.AddRange(this.GetImportSatisfyingAssignmentSyntax(satisfyingExport, provisionalSharedObjectsIdentifier, thisExportProvider));
                }

                if (part.Definition.OnImportsSatisfied != null)
                {
                    ExpressionSyntax receiver;
                    if (part.Definition.OnImportsSatisfied.DeclaringType.IsInterface)
                    {
                        var iface = SyntaxFactory.IdentifierName("onImportsSatisfiedInterface");
                        statements.Add(SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(SyntaxFactory.IdentifierName("var"))
                                .AddVariables(SyntaxFactory.VariableDeclarator(iface.Identifier).WithInitializer(
                                    SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.CastExpression(
                                            this.GetTypeNameSyntax(part.Definition.OnImportsSatisfied.DeclaringType),
                                            partInstanceIdentifier))))));
                        receiver = iface;
                    }
                    else
                    {
                        receiver = partInstanceIdentifier;
                    }

                    statements.Add(SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            receiver,
                            SyntaxFactory.IdentifierName(part.Definition.OnImportsSatisfied.Name)),
                        SyntaxFactory.ArgumentList())));
                }

                // return result;
                statements.Add(SyntaxFactory.ReturnStatement(partInstanceIdentifier));
            }
            else
            {
                statements.Add(SyntaxFactory.ReturnStatement(
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.IdentifierName("CannotInstantiatePartWithNoImportingConstructor"),
                        SyntaxFactory.ArgumentList())));
            }

            method = method.AddBodyStatements(statements.ToArray());

            return method;
        }

        private HashSet<Type> GetMetadataViewInterfaces()
        {
            var set = new HashSet<Type>();

            set.UnionWith(
                from part in this.Configuration.Parts
                from importAndExports in part.SatisfyingExports
                where importAndExports.Value.Count > 0
                let metadataType = importAndExports.Key.MetadataType
                where metadataType != null && metadataType.IsInterface && metadataType != typeof(IDictionary<string, object>)
                select metadataType);

            return set;
        }

        private ExpressionSyntax ExportFactoryCreationSyntax(ImportDefinitionBinding import, ExportDefinitionBinding export, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(import, "import");
            Requires.Argument(import.IsExportFactory, "import", "IsExportFactory is expected to be true.");
            Requires.NotNull(export, "export");
            Requires.NotNull(thisExportProvider, "thisExportProvider");

            // ExportFactory<T>.ctor(Func<Tuple<T, Action>>)
            // ExportFactory<T, TMetadata>.ctor(Func<Tuple<T, Action>>, TMetadata)
            var exportFactoryCtorArguments = new List<ExpressionSyntax>();

            // Prepare the export factory delegate.
            var statements = new List<StatementSyntax>();
            bool newSharingScope = import.ImportDefinition.ExportFactorySharingBoundaries.Count > 0;
            ExpressionSyntax scope;

            if (newSharingScope)
            {
                // var scope = new CompiledExportProvider(this, new [] { "sharing", "boundaries" });
                var scopeLocalVar = SyntaxFactory.IdentifierName("scope");
                statements.Add(
                    SyntaxFactory.LocalDeclarationStatement(
                        SyntaxFactory.VariableDeclaration(
                            SyntaxFactory.IdentifierName("var"),
                            SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.VariableDeclarator(scopeLocalVar.Identifier)
                                    .WithInitializer(SyntaxFactory.EqualsValueClause(
                                        SyntaxFactory.ObjectCreationExpression(
                                            SyntaxFactory.IdentifierName(CompiledExportProviderTypeName),
                                            SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                                                SyntaxKind.CommaToken,
                                                SyntaxFactory.Argument(thisExportProvider),
                                                SyntaxFactory.Argument(SyntaxFactory.ImplicitArrayCreationExpression(
                                                    SyntaxFactory.InitializerExpression(
                                                        SyntaxKind.ArrayInitializerExpression,
                                                        CodeGen.JoinSyntaxNodes<ExpressionSyntax>(SyntaxKind.CommaToken, import.ImportDefinition.ExportFactorySharingBoundaries.Select(sb => SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(sb))).ToArray())))))),
                                            null)))))));
                scope = scopeLocalVar;
            }
            else
            {
                // var scope = this;
                scope = thisExportProvider;
            }

            // ILazy<object> part = GetOrCreateShareableValue(typeof(Part), ...);
            Type[] typeArgs = import.ImportingSiteElementType.GetGenericArguments();
            var partLocalVar = SyntaxFactory.IdentifierName("part");
            statements.Add(
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.IdentifierName("var"),
                        SyntaxFactory.SingletonSeparatedList(
                            SyntaxFactory.VariableDeclarator(partLocalVar.Identifier)
                                .WithInitializer(SyntaxFactory.EqualsValueClause(
                                    GetPartInstanceLazy(export.PartDefinition, newDictionaryOfTypeObjectExpression, false, typeArgs, scope)))))));

            // var value = part.Value.SomeMember;
            var exportedValueLocalVar = SyntaxFactory.IdentifierName("value");
            statements.Add(
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.IdentifierName("var"),
                        SyntaxFactory.SingletonSeparatedList(
                            SyntaxFactory.VariableDeclarator(exportedValueLocalVar.Identifier)
                                .WithInitializer(SyntaxFactory.EqualsValueClause(
                                    GetExportedValueFromPart(partLocalVar, import, export, ValueFactoryType.ActualValue, thisExportProvider)))))));

            ExpressionSyntax disposeReceiver = null;
            if (newSharingScope)
            {
                disposeReceiver = scope;
            }
            else if (typeof(IDisposable).IsAssignableFrom(export.PartDefinition.Type))
            {
                disposeReceiver = SyntaxFactory.ParenthesizedExpression(SyntaxFactory.CastExpression(
                    SyntaxFactory.IdentifierName("IDisposable"),
                    SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, partLocalVar, SyntaxFactory.IdentifierName("Value"))));
            }

            ExpressionSyntax disposeAction = disposeReceiver != null
                ? (ExpressionSyntax)SyntaxFactory.ObjectCreationExpression(
                    SyntaxFactory.IdentifierName("Action"),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                        SyntaxFactory.ParenthesizedLambdaExpression(SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                disposeReceiver,
                                SyntaxFactory.IdentifierName("Dispose")),
                            SyntaxFactory.ArgumentList()))))),
                    null)
                : SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression);

            var tupleType = typeof(Tuple<,>).MakeGenericType(import.ImportingSiteElementType, typeof(Action));
            var tupleValue = (ExpressionSyntax)SyntaxFactory.CastExpression(this.GetTypeNameSyntax(import.ImportingSiteElementType), exportedValueLocalVar);

            var tupleExpression = this.ObjectCreationExpression(
                tupleType.GetConstructors().Single(),
                new ExpressionSyntax[] { tupleValue, disposeAction },
                thisExportProvider);
            statements.Add(SyntaxFactory.ReturnStatement(tupleExpression));

            var tupleFactoryLambda = SyntaxFactory.ParenthesizedLambdaExpression(SyntaxFactory.Block(statements));
            if (IsPublic(import.ExportFactoryType, true))
            {
                exportFactoryCtorArguments.Add(tupleFactoryLambda);
            }
            else
            {
                // Since we'll be using reflection to pass in the tuple factory, we have to
                // explicitly give the lambda a delegate shape or the C# compiler won't know what to do with it.
                var tupleFactoryDelegate = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName("ReflectionHelpers"),
                        SyntaxFactory.IdentifierName("CreateFuncOfType")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(this.GetTypeExpressionSyntax(tupleType, thisExportProvider)),
                        SyntaxFactory.Argument(tupleFactoryLambda))));
                exportFactoryCtorArguments.Add(tupleFactoryDelegate);
            }

            // Add the metadata argument if applicable.
            if (import.ExportFactoryType.GenericTypeArguments.Length > 1)
            {
                exportFactoryCtorArguments.Add(GetExportMetadata(export, import, thisExportProvider));
            }

            return this.ObjectCreationExpression(
                import.ExportFactoryType.GetConstructors().Single(),
                exportFactoryCtorArguments.ToArray(),
                thisExportProvider);
        }

        private enum ValueFactoryType
        {
            ActualValue,
            LazyOfT,
            FuncOfObject,
        }

        private ExpressionSyntax ConvertValue(ExpressionSyntax value, TypeSyntax valueType, ValueFactoryType current, ValueFactoryType target)
        {
            switch (current)
            {
                case ValueFactoryType.ActualValue:
                    switch (target)
                    {
                        case ValueFactoryType.ActualValue:
                            return value;
                        case ValueFactoryType.LazyOfT:
                            // new Lazy<T>(() => value)
                            throw new NotImplementedException();
                        case ValueFactoryType.FuncOfObject:
                            // new Func<object>(() => value)
                            var lambda = SyntaxFactory.ParenthesizedLambdaExpression(value);
                            return SyntaxFactory.ObjectCreationExpression(
                                SyntaxFactory.GenericName("Func").AddTypeArgumentListArguments(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword))),
                                SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(lambda))),
                                null);
                        default:
                            throw new ArgumentOutOfRangeException("target");
                    }
                case ValueFactoryType.LazyOfT:
                    switch (target)
                    {
                        case ValueFactoryType.ActualValue:
                            // value.Value;
                            return SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, value, SyntaxFactory.IdentifierName("Value"));
                        case ValueFactoryType.LazyOfT:
                            return value;
                        case ValueFactoryType.FuncOfObject:
                            // value.ValueFactory;
                            return SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, value, SyntaxFactory.IdentifierName("ValueFactory"));
                        default:
                            throw new ArgumentOutOfRangeException("target");
                    }
                case ValueFactoryType.FuncOfObject:
                    switch (target)
                    {
                        case ValueFactoryType.ActualValue:
                            return SyntaxFactory.InvocationExpression(value, SyntaxFactory.ArgumentList());
                        case ValueFactoryType.LazyOfT:
                            // new Lazy<T>(value)
                            throw new NotImplementedException();
                        case ValueFactoryType.FuncOfObject:
                            return value;
                        default:
                            throw new ArgumentOutOfRangeException("target");
                    }
                default:
                    throw new ArgumentOutOfRangeException("current");
            }
        }

        private ExpressionSyntax GetExportedValueFromPart(ExpressionSyntax lazyPart, ImportDefinitionBinding import, ExportDefinitionBinding export, ValueFactoryType lazyType, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(lazyPart, "lazyPart");
            Requires.NotNull(import, "import");
            Requires.NotNull(export, "export");

            if (export.ExportingMember == null)
            {
                return this.ConvertValue(lazyPart, this.GetTypeNameSyntax(export.PartDefinition.Type), ValueFactoryType.LazyOfT, lazyType);
            }

            // To retrieve a member, we must have the actual instance that hosts it.
            var partInstance = this.ConvertValue(lazyPart, this.GetTypeNameSyntax(export.PartDefinition.Type), ValueFactoryType.LazyOfT, ValueFactoryType.ActualValue);

            var memberValue = CreateMemberRetrieval(export.ExportingMember, partInstance, thisExportProvider);
            switch (export.ExportingMember.MemberType)
            {
                case MemberTypes.Method:
                    var delegateType = typeof(Delegate).IsAssignableFrom(import.ImportingSiteElementType) ? import.ImportingSiteElementType : export.ExportedValueType;
                    if (IsPublic(delegateType, true) && IsPublic(export.ExportingMember, export.PartDefinition.Type))
                    {
                        memberValue = this.ObjectCreationExpression(
                            delegateType.GetConstructors().Single(),
                            new ExpressionSyntax[] { memberValue },
                            thisExportProvider);
                    }
                    else
                    {
                        // memberValue.CreateDelegate(delegateType, partInstance)
                        memberValue = SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                memberValue,
                                SyntaxFactory.IdentifierName("CreateDelegate")),
                            SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                                SyntaxKind.CommaToken,
                                SyntaxFactory.Argument(this.GetTypeExpressionSyntax(delegateType, thisExportProvider)),
                                SyntaxFactory.Argument(partInstance))));
                    }

                    break;
            }

            return this.ConvertValue(memberValue, this.GetTypeNameSyntax(import.ImportingSiteElementType), ValueFactoryType.ActualValue, lazyType);
        }

        private ExpressionSyntax GetImportAssignableValueForExport(ImportDefinitionBinding import, ExportDefinitionBinding export, ExpressionSyntax provisionalSharedObjects, ExpressionSyntax scopeExportProvider)
        {
            Requires.NotNull(import, "import");
            Requires.NotNull(export, "export");
            Requires.NotNull(provisionalSharedObjects, "provisionalSharedObjects");
            Requires.NotNull(scopeExportProvider, "scopeExportProvider");

            if (import.IsExportFactory)
            {
                return this.ExportFactoryCreationSyntax(import, export, scopeExportProvider);
            }

            bool isNonSharedInstanceRequired = PartCreationPolicyConstraint.IsNonSharedInstanceRequired(import.ImportDefinition);
            Type[] typeArgs = import.ImportingSiteElementType.GetGenericArguments();
            var exportedValueSyntax = GetExportedValueFromPart(
                    GetPartInstanceLazy(export.PartDefinition, provisionalSharedObjects, isNonSharedInstanceRequired, typeArgs, scopeExportProvider),
                    import,
                    export,
                    import.IsLazy ? ValueFactoryType.FuncOfObject : ValueFactoryType.ActualValue,
                    scopeExportProvider);

            if (import.IsLazy)
            {
                if (!export.IsStaticExport && !export.PartDefinition.IsInstantiable)
                {
                    // Don't bother with code for generating a part we can't access. Just emit code to throw.
                    exportedValueSyntax = SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName("NotInstantiablePartLazy"),
                        SyntaxFactory.IdentifierName("ValueFactory"));
                }

                var lazyExportedValueSyntax = CreateLazyConstruction(
                    import.ImportingSiteElementType,
                    exportedValueSyntax,
                    import.MetadataType,
                    GetExportMetadata(export, import, scopeExportProvider),
                    scopeExportProvider);
                return lazyExportedValueSyntax;
            }
            else
            {
                return SyntaxFactory.CastExpression(
                    this.GetTypeNameSyntax(import.ImportingSiteElementType),
                    exportedValueSyntax);
            }
        }

        private MethodDeclarationSyntax CreateGetExportsCoreHelperMethod(IGrouping<string, ExportDefinitionBinding> exports, IdentifierNameSyntax importDefinition)
        {
            Requires.NotNull(exports, "exports");

            var thisExportProviderIdentifier = SyntaxFactory.IdentifierName("that");
            var thisExportProvider = SyntaxFactory.ParenthesizedExpression(SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(CompiledExportProviderTypeName), thisExportProviderIdentifier));
            var exportExpressions = exports.Select(e => this.ExportCreationSyntax(e, importDefinition, thisExportProvider)).ToArray();

            var exportArrayType = SyntaxFactory.ArrayType(
                    SyntaxFactory.IdentifierName("Export"),
                    SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>(
                        SyntaxFactory.ArrayRankSpecifier(
                            SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                SyntaxFactory.OmittedArraySizeExpression()))));

            var exportArrayExpression = SyntaxFactory.ArrayCreationExpression(exportArrayType)
                .WithInitializer(SyntaxFactory.InitializerExpression(SyntaxKind.ArrayInitializerExpression, CodeGen.JoinSyntaxNodes<ExpressionSyntax>(SyntaxKind.CommaToken, exportExpressions)));

            var method = SyntaxFactory.MethodDeclaration(
                exportArrayType,
                SyntaxFactory.Identifier(GetGetExportsCoreHelperMethodName(exports.Key)))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.InternalKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(thisExportProviderIdentifier.Identifier).WithType(this.GetTypeNameSyntax(typeof(ExportProvider))),
                    SyntaxFactory.Parameter(importDefinition.Identifier).WithType(SyntaxFactory.IdentifierName("ImportDefinition")))
                .AddBodyStatements(SyntaxFactory.ReturnStatement(exportArrayExpression));
            return method;
        }

        private ExpressionSyntax GetExportMetadata(ExportDefinitionBinding export, ImportDefinitionBinding import, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(export, "export");

            var metadataDictionary = this.GetExportMetadata(export, thisExportProvider);
            if (import == null || import.MetadataType == null || import.MetadataType == typeof(IDictionary<string, object>))
            {
                return metadataDictionary;
            }
            else if (import.MetadataType.IsInterface)
            {
                return SyntaxFactory.ObjectCreationExpression(
                    SyntaxFactory.IdentifierName(GetClassNameForMetadataView(import.MetadataType)),
                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(metadataDictionary))),
                    null);
            }
            else
            {
                return this.ObjectCreationExpression(
                    import.MetadataType.GetConstructor(new Type[] { typeof(IDictionary<string, object>) }),
                    new ExpressionSyntax[] { metadataDictionary },
                    thisExportProvider);
            }
        }

        private IEnumerable<IGrouping<string, ExportDefinitionBinding>> ExportsByContract
        {
            get
            {
                return
                    from part in this.Configuration.Parts
                    from exportingMemberAndDefinition in part.Definition.ExportDefinitions
                    let export = new ExportDefinitionBinding(exportingMemberAndDefinition.Value, part.Definition, exportingMemberAndDefinition.Key)
                    where part.Definition.IsInstantiable
                    group export by export.ExportDefinition.ContractName into exportsByContract
                    select exportsByContract;
            }
        }

        private string GetTypeName(Type type)
        {
            return this.GetTypeName(type, false, false);
        }

        private string GetTypeName(Type type, bool genericTypeDefinition = false, bool evenNonPublic = false)
        {
            return ReflectionHelpers.GetTypeName(type, genericTypeDefinition, evenNonPublic, this.relevantAssemblies, this.relevantEmbeddedTypes);
        }

        private ExpressionSyntax GetTypeExpressionSyntax(Type type, ExpressionSyntax thisExportProvider, bool genericTypeDefinition = false, bool assumeNonPublic = false)
        {
            Requires.NotNull(type, "type");
            Requires.NotNull(thisExportProvider, "thisExportProvider");

            if (!assumeNonPublic && IsPublic(type, true) && !type.IsEmbeddedType()) // embedded types need to be matched to their receiving assembly
            {
                return SyntaxFactory.TypeOfExpression(this.GetTypeNameSyntax(type, genericTypeDefinition));
            }
            else
            {
                var targetType = (genericTypeDefinition && type.IsGenericType) ? type.GetGenericTypeDefinition() : type;

                var deterministicTypeExpression = this.GetTypeSyntax(targetType, thisExportProvider);

                if (!genericTypeDefinition && targetType.GetTypeInfo().ContainsGenericParameters)
                {
                    // Concatenate on the generic type arguments if the caller didn't explicitly want the generic type definition.
                    // Note that the type itself may be a generic type definition, in which case the concatenated types might be
                    // T1, T2. That's fine. In fact that's what we want because it causes the types from the caller's caller to
                    // propagate.
                    var constructedTypeExpression = SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            deterministicTypeExpression,
                            SyntaxFactory.IdentifierName("MakeGenericType")),
                        SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes<ArgumentSyntax>(
                            SyntaxKind.CommaToken,
                            targetType.GetGenericArguments().Select(arg => SyntaxFactory.Argument(this.GetTypeExpressionSyntax(arg, thisExportProvider, false))).ToArray())));
                    return constructedTypeExpression;
                }

                return deterministicTypeExpression;
            }
        }

        /// <summary>
        /// Gets a C# expression that evaluates to a System.Type instance for the specified type.
        /// </summary>
        private string GetTypeExpression(Type type, ExpressionSyntax thisExportProvider, bool genericTypeDefinition = false, bool assumeNonPublic = false)
        {
            return this.GetTypeExpressionSyntax(type, thisExportProvider, genericTypeDefinition, assumeNonPublic)
                .NormalizeWhitespace().ToString();
        }

        private static bool IsPublic(Type type, bool checkGenericTypeArgs = false)
        {
            return ReflectionHelpers.IsPublic(type, checkGenericTypeArgs);
        }

        private string GetClassNameForMetadataView(Type metadataView)
        {
            Requires.NotNull(metadataView, "metadataView");

            return ReserveClassSymbolName(
                metadataView.IsInterface ? "ClassFor" + metadataView.Name : this.GetTypeName(metadataView),
                metadataView);
        }

        private ExpressionSyntax GetValueOrDefaultForMetadataView(PropertyInfo property, IdentifierNameSyntax metadata, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(property, "property");
            Requires.NotNull(metadata, "metadata");

            var elementAccess = SyntaxFactory.ElementAccessExpression(
                metadata,
                SyntaxFactory.BracketedArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                    SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(property.Name))))));
            var elementAccessWithCast = ReflectionHelpers.GetMemberType(property).IsValueType
                ? (ExpressionSyntax)SyntaxFactory.CastExpression(this.GetTypeNameSyntax(ReflectionHelpers.GetMemberType(property)), elementAccess)
                : SyntaxFactory.BinaryExpression(SyntaxKind.AsExpression, elementAccess, this.GetTypeNameSyntax(ReflectionHelpers.GetMemberType(property)));

            var defaultValueAttribute = property.GetCustomAttributesCached<DefaultValueAttribute>().FirstOrDefault();
            if (defaultValueAttribute != null)
            {
                var defaultValue = SyntaxFactory.CastExpression(
                    this.GetTypeNameSyntax(ReflectionHelpers.GetMemberType(property)),
                    GetSyntaxToReconstructValue(defaultValueAttribute.Value, thisExportProvider));

                return SyntaxFactory.ConditionalExpression(
                    SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            metadata,
                            SyntaxFactory.IdentifierName("ContainsKey")),
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                            SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(property.Name)))))),
                    elementAccessWithCast,
                    defaultValue);
            }
            else
            {
                return elementAccessWithCast;
            }
        }

        private static void Test<T>() { }

        private static string GetPartFactoryMethodNameNoTypeArgs(ComposablePartDefinition part)
        {
            Requires.NotNull(part, "part");
            string name = "Create" + part.Id;
            return name;
        }

        private static string GetPartFactoryMethodName(ComposablePartDefinition part, params string[] typeArguments)
        {
            if (typeArguments == null || typeArguments.Length == 0)
            {
                typeArguments = part.Type.GetGenericArguments().Select(t => t.Name).ToArray();
            }

            string name = GetPartFactoryMethodNameNoTypeArgs(part);

            if (typeArguments.Length > 0)
            {
                name += "<";
                name += string.Join(",", typeArguments);
                name += ">";
            }

            return name;
        }

        private static string HashIdentifierAcrossBuckets(string prefix, string value, int desiredBucketCount)
        {
            return Utilities.MakeIdentifierNameSafe(prefix + (Math.Abs(value.GetHashCode()) % desiredBucketCount));
        }

        private static string GetPartFactoryDeclaringTypeName(ComposablePartDefinition part)
        {
            Requires.NotNull(part, "part");

            return HashIdentifierAcrossBuckets(part.Type.Assembly.GetName().Name, part.Type.Name, 12);
        }

        private static string Quote(string value)
        {
            return "@\"" + value.Replace("\"", "\"\"") + "\"";
        }

        private static bool IsPublic(MemberInfo memberInfo, Type reflectedType, bool setter = false)
        {
            Requires.NotNull(memberInfo, "memberInfo");
            Requires.NotNull(reflectedType, "reflectedType");
            Requires.Argument(memberInfo.ReflectedType.IsAssignableFrom(reflectedType), "reflectedType", "Type must be the one that defines memberInfo or a derived type.");

            if (!IsPublic(reflectedType, true))
            {
                return false;
            }

            var obsoleteAttribute = memberInfo.GetCustomAttributesCached<ObsoleteAttribute>().FirstOrDefault();
            if (obsoleteAttribute != null && obsoleteAttribute.IsError)
            {
                // It would generate a compile error if we referenced this member directly, so consider it non-public.
                return false;
            }

            switch (memberInfo.MemberType)
            {
                case MemberTypes.Constructor:
                    return ((ConstructorInfo)memberInfo).IsPublic;
                case MemberTypes.Field:
                    var fieldInfo = (FieldInfo)memberInfo;
                    return fieldInfo.IsPublic && IsPublic(ReflectionHelpers.GetMemberType(fieldInfo), true); // we have to check the type in case it contains embedded generic type arguments
                case MemberTypes.Method:
                    return ((MethodInfo)memberInfo).IsPublic;
                case MemberTypes.Property:
                    var property = (PropertyInfo)memberInfo;
                    var method = setter ? property.GetSetMethod(true) : property.GetGetMethod(true);
                    return IsPublic(method, reflectedType) && IsPublic(ReflectionHelpers.GetMemberType(property), true); // we have to check the type in case it contains embedded generic type arguments
                default:
                    throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Creates an expression that creates a <see cref="LazyPart{T, TMetadata}"/> instance.
        /// </summary>
        /// <param name="valueType">The type for T.</param>
        /// <param name="valueFactory">The value factory, including the lambda when applicable.</param>
        /// <param name="metadataType">The type for TMetadata.</param>
        /// <param name="metadata">The metadata.</param>
        /// <returns>The object creation expression.</returns>
        private ExpressionSyntax CreateLazyConstruction(Type valueType, ExpressionSyntax valueFactory, Type metadataType, ExpressionSyntax metadata, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(valueType, "valueType");
            Requires.NotNull(valueFactory, "valueFactory");

            Type lazyTypeDefinition = metadataType != null ? typeof(LazyPart<,>) : typeof(LazyPart<>);
            Type[] lazyTypeArgs = metadataType != null ? new[] { valueType, metadataType } : new[] { valueType };
            Type lazyType = lazyTypeDefinition.MakeGenericType(lazyTypeArgs);
            ExpressionSyntax[] lazyArgs = metadataType == null ? new[] { valueFactory } : new[] { valueFactory, metadata };

            var ctor = lazyType.GetConstructors().First(c => c.GetParameters()[0].ParameterType.Equals(typeof(Func<object>)));
            var lazyConstruction = this.ObjectCreationExpression(ctor, lazyArgs, thisExportProvider);
            return lazyConstruction;
        }

        private int GetManifestModuleId(Assembly assembly)
        {
            Requires.NotNull(assembly, "assembly");

            // Ensure that this assembly has been assigned an index, which we'll use in the generated code.
            int index = this.reflectionLoadedAssemblies.IndexOf(assembly);
            if (index < 0)
            {
                this.reflectionLoadedAssemblies.Add(assembly);
                index = this.reflectionLoadedAssemblies.Count - 1;
            }

            return index;
        }

        private LiteralExpressionSyntax GetManifestModuleIdSyntax(Assembly assembly)
        {
            Requires.NotNull(assembly, "assembly");

            int index = GetManifestModuleId(assembly);
            var indexExpression = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(index))
                .WithTrailingTrivia(SyntaxFactory.Comment("/* " + assembly.GetName().Name + "*/"));

            return indexExpression;
        }

        /// <summary>
        /// Gets the expression syntax for the manifest module of the given assembly.
        /// </summary>
        /// <param name="assembly">The assembly for which the manifest module is required by the generated code.</param>
        /// <param name="thisExportProvider">The expression to refer to "this" CompiledExportProvider.</param>
        /// <returns>The expression syntax.</returns>
        private ExpressionSyntax GetManifestModuleSyntax(Assembly assembly, ExpressionSyntax thisExportProvider)
        {
            var index = this.GetManifestModuleIdSyntax(assembly);

            // CODE: this.GetAssemblyManifest(index)
            return SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    thisExportProvider,
                    SyntaxFactory.IdentifierName("GetAssemblyManifest")),
                SyntaxFactory.ArgumentList(
                    SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                        SyntaxFactory.Argument(
                            index))));
        }

        private int GetTypeId(Type type)
        {
            Requires.NotNull(type, "type");

            // Ensure that this type has been assigned an index, which we'll use in the generated code.
            int index = this.reflectionLoadedTypes.IndexOf(type);
            if (index < 0)
            {
                this.reflectionLoadedTypes.Add(type);
                index = this.reflectionLoadedTypes.Count - 1;
            }

            return index;
        }

        private LiteralExpressionSyntax GetTypeIdSyntax(Type type)
        {
            int index = GetTypeId(type);

            var indexExpression = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(index))
                .WithTrailingTrivia(SyntaxFactory.Comment("/* " + this.GetTypeName(type, evenNonPublic: true) + "*/"));

            return indexExpression;
        }

        private ExpressionSyntax GetTypeSyntax(Type type, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(type, "type");
            Requires.NotNull(thisExportProvider, "thisExportProvider");

            var index = this.GetTypeIdSyntax(type);

            // this.GetType(index)
            var typeExpression = SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    thisExportProvider,
                    SyntaxFactory.IdentifierName("GetType")),
                SyntaxFactory.ArgumentList(
                    SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                        SyntaxFactory.Argument(index))));

            return typeExpression;
        }

        private ExpressionSyntax ExportCreationSyntax(ExportDefinitionBinding export, IdentifierNameSyntax importDefinition, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(export, "export");
            Requires.NotNull(importDefinition, "importDefinition");

            bool isOpenGenericExport = export.ExportedValueType.ContainsGenericParameters;
            var partDefinition = export.PartDefinition;
            ExpressionSyntax partTypeExpression = this.GetTypeIdSyntax(
                isOpenGenericExport ? partDefinition.Type.GetGenericTypeDefinition() : partDefinition.Type);

            ExpressionSyntax partFactoryMethod;
            ExpressionSyntax partFactoryMethodDeclaringType = null;
            if (isOpenGenericExport)
            {
                partFactoryMethodDeclaringType = SyntaxFactory.TypeOfExpression(
                    SyntaxFactory.IdentifierName(GetPartFactoryDeclaringTypeName(partDefinition)));
                partFactoryMethod = SyntaxFactory.LiteralExpression(
                    SyntaxKind.StringLiteralExpression,
                    SyntaxFactory.Literal(GetPartFactoryMethodNameNoTypeArgs(partDefinition)));
            }
            else
            {
                partFactoryMethod = SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.IdentifierName(GetPartFactoryDeclaringTypeName(partDefinition)),
                    SyntaxFactory.IdentifierName(GetPartFactoryMethodName(partDefinition)));
            }

            ExpressionSyntax sharingBoundary = partDefinition.IsShared
                ? SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(this.Configuration.GetEffectiveSharingBoundary(partDefinition)))
                : SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression);

            bool nonSharedInstanceRequired = !partDefinition.IsShared;

            ExpressionSyntax exportingMemberExpression = export.ExportingMember != null
                ? this.GetMemberInfoSyntax(export.ExportingMember, thisExportProvider)
                : SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression);

            var arguments = new List<ExpressionSyntax> {
                importDefinition,
                GetExportMetadata(export, thisExportProvider),
                partTypeExpression,
                partFactoryMethod,
                sharingBoundary,
                SyntaxFactory.LiteralExpression(nonSharedInstanceRequired ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression),
                exportingMemberExpression,
            };

            if (partFactoryMethodDeclaringType != null)
            {
                arguments.Insert(3, partFactoryMethodDeclaringType);
            }

            var createExport = SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    thisExportProvider,
                    SyntaxFactory.IdentifierName("CreateExport")),
                SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                    SyntaxKind.CommaToken,
                    arguments.Select(SyntaxFactory.Argument).ToArray())));

            return createExport;
        }

        /// <summary>
        /// Creates an expression that evaluates to an <see cref="ILazy{Object}"/>.
        /// </summary>
        private ExpressionSyntax GetPartInstanceLazy(ComposablePartDefinition partDefinition, ExpressionSyntax provisionalSharedObjects, bool nonSharedInstanceRequired, IReadOnlyList<Type> typeArgs, ExpressionSyntax scopeExportProvider)
        {
            Requires.NotNull(partDefinition, "partDefinition");
            Requires.NotNull(provisionalSharedObjects, "provisionalSharedObjects");

            // typeArgs may be supplied to us for an import of "Func<object>" even though the exporter is just a method.
            if (typeArgs == null || !partDefinition.Type.IsGenericTypeDefinition)
            {
                typeArgs = ImmutableList<Type>.Empty;
            }

            // Force the query to be for an isolated instance if the instance is never shared.
            nonSharedInstanceRequired |= !partDefinition.IsShared;

            if (partDefinition.Equals(ExportProvider.ExportProviderPartDefinition))
            {
                // Special case for our synthesized part that acts as a placeholder for *this* export provider.
                // this.NonDisposableWrapper
                return SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    scopeExportProvider,
                    SyntaxFactory.IdentifierName("NonDisposableWrapper"));
            }

            Type partType = typeArgs.Count == 0 ? partDefinition.Type : partDefinition.Type.MakeGenericType(typeArgs.ToArray());
            ExpressionSyntax partTypeExpression = this.GetTypeIdSyntax(partType);
            SimpleNameSyntax partFactoryMethodName = SyntaxFactory.IdentifierName(GetPartFactoryMethodNameNoTypeArgs(partDefinition));
            ExpressionSyntax partFactoryMethod;
            bool publicInvocation = typeArgs.All(t => IsPublic(t, true));
            if (publicInvocation)
            {
                var typeArgsSyntax = typeArgs.Select(t => this.GetTypeNameSyntax(t)).ToArray();
                if (typeArgs.Count > 0)
                {
                    partFactoryMethodName = SyntaxFactory.GenericName(
                        partFactoryMethodName.Identifier,
                        SyntaxFactory.TypeArgumentList(CodeGen.JoinSyntaxNodes(SyntaxKind.CommaToken, typeArgsSyntax)));
                }

                // scope.CreateSomePart<T1, T2>
                partFactoryMethod = SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName(GetPartFactoryDeclaringTypeName(partDefinition)),
                        partFactoryMethodName);
            }
            else
            {
                var typeArgsExpressionSyntax = typeArgs.Select(t => this.GetTypeExpressionSyntax(t, scopeExportProvider)).ToArray();

                // GetMethodWithArity(typeof(NestedClass), "CreateSomePart", 2).MakeGenericMethod(typeof(T1), typeof(T2)).CreateDelegate(typeof(Func<Dictionary<Type, object>, object>), scope)
                var getMethodWithArity = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        scopeExportProvider,
                        SyntaxFactory.IdentifierName("GetMethodWithArity")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(SyntaxFactory.TypeOfExpression(SyntaxFactory.IdentifierName(GetPartFactoryDeclaringTypeName(partDefinition)))),
                        SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(partFactoryMethodName.Identifier.ToString()))),
                        SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(typeArgs.Count))))));
                var makeGenericMethod = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        getMethodWithArity,
                        SyntaxFactory.IdentifierName("MakeGenericMethod")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(SyntaxKind.CommaToken, typeArgsExpressionSyntax.Select(SyntaxFactory.Argument).ToArray())));
                var funcOfProviderDictionaryObject = SyntaxFactory.GenericName("Func")
                    .AddTypeArgumentListArguments(
                        SyntaxFactory.IdentifierName("ExportProvider"),
                        dictionaryOfIntObject,
                        SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.ObjectKeyword)));
                var createDelegate = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        makeGenericMethod,
                        SyntaxFactory.IdentifierName("CreateDelegate")),
                    SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                        SyntaxKind.CommaToken,
                        SyntaxFactory.Argument(SyntaxFactory.TypeOfExpression(funcOfProviderDictionaryObject)),
                        SyntaxFactory.Argument(NullSyntax))));
                partFactoryMethod = SyntaxFactory.CastExpression(funcOfProviderDictionaryObject, createDelegate);
            }

            ExpressionSyntax sharingBoundary = partDefinition.IsShared
                ? SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(this.Configuration.GetEffectiveSharingBoundary(partDefinition)))
                : SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression);

            // this.GetOrCreateShareableValue(typeof(Part), this.CreatePart, pso, "sharingBoundaries", true)
            var invocation = SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    scopeExportProvider,
                    SyntaxFactory.IdentifierName("GetOrCreateShareableValue")),
                SyntaxFactory.ArgumentList(CodeGen.JoinSyntaxNodes(
                    SyntaxKind.CommaToken,
                    SyntaxFactory.Argument(partTypeExpression),
                    SyntaxFactory.Argument(partFactoryMethod),
                    SyntaxFactory.Argument(provisionalSharedObjects),
                    SyntaxFactory.Argument(sharingBoundary),
                    SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(nonSharedInstanceRequired ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression)))));

            return invocation;
        }

        private MemberDeclarationSyntax CreateGetTypeIdCoreMethod()
        {
            var typeParameter = SyntaxFactory.IdentifierName("type");
            var method = SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                "GetTypeIdCore")
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
                    SyntaxFactory.Token(SyntaxKind.OverrideKeyword))
                .WithParameterList(SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList<ParameterSyntax>(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.List<AttributeListSyntax>(),
                        SyntaxFactory.TokenList(),
                        this.GetTypeNameSyntax(typeof(Type)),
                        typeParameter.Identifier,
                        null))));

            var statements = new List<StatementSyntax>();

            var fullTypeName = SyntaxFactory.IdentifierName("fullTypeName");
            statements.Add(SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                SyntaxFactory.SingletonSeparatedList(SyntaxFactory.VariableDeclarator(
                    fullTypeName.Identifier,
                    null,
                    SyntaxFactory.EqualsValueClause(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            typeParameter,
                            SyntaxFactory.IdentifierName("FullName"))))))));
            var assemblyFullName = SyntaxFactory.IdentifierName("assemblyFullName");
            statements.Add(SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)),
                SyntaxFactory.SingletonSeparatedList(SyntaxFactory.VariableDeclarator(
                    assemblyFullName.Identifier,
                    null,
                    SyntaxFactory.EqualsValueClause(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        typeParameter,
                                        SyntaxFactory.IdentifierName("GetTypeInfo")),
                                    SyntaxFactory.ArgumentList()),
                                SyntaxFactory.IdentifierName("Assembly")),
                            SyntaxFactory.IdentifierName("FullName"))))))));

            var returnMinusOneSection = SyntaxFactory.SwitchSection(
                SyntaxFactory.SingletonList<SwitchLabelSyntax>(
                    SyntaxFactory.SwitchLabel(SyntaxKind.DefaultSwitchLabel)),
                SyntaxFactory.SingletonList<StatementSyntax>(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(-1)))));

            Func<string, StatementSyntax, SwitchSectionSyntax> createSection = (label, statement) => SyntaxFactory.SwitchSection(
                SyntaxFactory.SingletonList(SyntaxFactory.SwitchLabel(SyntaxKind.CaseSwitchLabel, SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(label)))),
                SyntaxFactory.SingletonList(statement));

            var assemblySwitchStatement = SyntaxFactory.SwitchStatement(assemblyFullName);
            foreach (var assembly in this.reflectionLoadedTypes.Select(t => t.Assembly).Distinct())
            {
                var typeSwitchStatement = SyntaxFactory.SwitchStatement(fullTypeName);
                for (int i = 0; i < this.reflectionLoadedTypes.Count; i++)
                {
                    Type type = this.reflectionLoadedTypes[i];
                    if (type.Assembly == assembly)
                    {
                        typeSwitchStatement = typeSwitchStatement.AddSections(createSection(
                            type.FullName,
                            SyntaxFactory.ReturnStatement(SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(i)))));
                    }
                }

                typeSwitchStatement = typeSwitchStatement.AddSections(returnMinusOneSection);
                assemblySwitchStatement = assemblySwitchStatement.AddSections(createSection(assembly.FullName, typeSwitchStatement));
            }

            assemblySwitchStatement = assemblySwitchStatement.AddSections(returnMinusOneSection);

            statements.Add(assemblySwitchStatement);
            method = method.WithBody(SyntaxFactory.Block(statements));
            return method;
        }

        private MemberDeclarationSyntax CreateField(SyntaxToken fieldName, TypeSyntax fieldType, object value, ExpressionSyntax thisExportProvider)
        {
            Requires.NotNull(fieldType, "fieldType");

            var initializedValue = GetSyntaxToReconstructValue(value, thisExportProvider);

            return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(fieldType, SyntaxFactory.SingletonSeparatedList(
                    SyntaxFactory.VariableDeclarator(
                        fieldName,
                        null,
                        SyntaxFactory.EqualsValueClause(initializedValue)))))
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                    SyntaxFactory.Token(SyntaxKind.StaticKeyword),
                    SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword));
        }

        private MemberDeclarationSyntax CreateGetTypeCoreMethod()
        {
            this.EnsureTypeArgumentsAreDescribed();

            var intArrayType = SyntaxFactory.ArrayType(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                SyntaxFactory.SingletonList(SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(SyntaxFactory.OmittedArraySizeExpression()))));
            var assemblyArray = SyntaxFactory.IdentifierName("typeAssemblyId");
            this.extraMembers.Add(this.CreateField(
                assemblyArray.Identifier,
                intArrayType,
                this.reflectionLoadedTypes.Select(t => GetManifestModuleId(t.Assembly)).ToArray(),
                SyntaxFactory.ThisExpression()));
            var typeArray = SyntaxFactory.IdentifierName("typeTypeId");
            this.extraMembers.Add(this.CreateField(
                typeArray.Identifier,
                intArrayType,
                this.reflectionLoadedTypes.Select(t => t.MetadataToken).ToArray(),
                SyntaxFactory.ThisExpression()));
            var typeGenericArgArray = SyntaxFactory.IdentifierName("typeGenericArgumentId");
            this.extraMembers.Add(this.CreateField(
                typeGenericArgArray.Identifier,
                SyntaxFactory.ArrayType(intArrayType, SyntaxFactory.SingletonList(SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(SyntaxFactory.OmittedArraySizeExpression())))),
                this.reflectionLoadedTypes.Select(t => (t.IsGenericType && !t.IsGenericTypeDefinition) ? t.GenericTypeArguments.Select(GetTypeId).ToArray() : null).ToArray(),
                SyntaxFactory.ThisExpression()));

            var typeLocalVar = SyntaxFactory.IdentifierName("type");
            var typeIdParameter = SyntaxFactory.IdentifierName("typeId");
            var bracketTypeId = SyntaxFactory.BracketedArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(typeIdParameter)));
            var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.IdentifierName("Type"), "GetTypeCore")
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
                    SyntaxFactory.Token(SyntaxKind.OverrideKeyword))
                .WithParameterList(SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList<ParameterSyntax>(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.List<AttributeListSyntax>(),
                        SyntaxFactory.TokenList(),
                        SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                        typeIdParameter.Identifier,
                        null))))
                .AddBodyStatements(
                    SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.IdentifierName("Type"),
                        SyntaxFactory.SingletonSeparatedList(SyntaxFactory.VariableDeclarator(
                            typeLocalVar.Identifier,
                            null,
                            SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                SyntaxFactory.ThisExpression(),
                                                SyntaxFactory.IdentifierName("GetAssemblyManifest")),
                                            SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(
                                                SyntaxFactory.Argument(SyntaxFactory.ElementAccessExpression(assemblyArray, bracketTypeId))))),
                                        SyntaxFactory.IdentifierName("ResolveType")),
                                    SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                                        SyntaxFactory.ElementAccessExpression(typeArray, bracketTypeId)))))))))),
                SyntaxFactory.IfStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKind.NotEqualsExpression,
                        SyntaxFactory.ElementAccessExpression(typeGenericArgArray, bracketTypeId),
                        NullSyntax),
                // type = type.MakeGenericType(typeGenericArgumentId[typeId].Select(GetTypeCore).ToArray())
                    SyntaxFactory.ExpressionStatement(SyntaxFactory.BinaryExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        typeLocalVar,
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                typeLocalVar,
                                SyntaxFactory.IdentifierName("MakeGenericType")),
                            SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.InvocationExpression(
                                            SyntaxFactory.MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                SyntaxFactory.ElementAccessExpression(typeGenericArgArray, bracketTypeId),
                                                SyntaxFactory.IdentifierName("Select")),
                                            SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(
                                                SyntaxFactory.Argument(SyntaxFactory.IdentifierName("GetTypeCore"))))),
                                        SyntaxFactory.IdentifierName("ToArray")),
                                    SyntaxFactory.ArgumentList())))))))),
                SyntaxFactory.ReturnStatement(typeLocalVar));
            return method;
        }

        private void EnsureTypeArgumentsAreDescribed()
        {
            // Loop over all types and ensure that generic types have already had their arguments added.
            for (int i = 0; i < this.reflectionLoadedTypes.Count; i++) // use for, not foreach, since the list can change during the loop.
            {
                Type type = this.reflectionLoadedTypes[i];
                if (type.IsGenericType && !type.IsGenericTypeDefinition)
                {
                    foreach (Type typeArg in type.GenericTypeArguments)
                    {
                        this.GetTypeId(typeArg); // force an entry in the array.
                    }
                }
            }
        }

        private string ReserveLocalVarName(string desiredName, HashSet<string> localSymbols = null)
        {
            localSymbols = localSymbols ?? this.localSymbols;

            if (localSymbols.Add(desiredName))
            {
                return desiredName;
            }

            int i = 0;
            string candidateName;
            do
            {
                i++;
                candidateName = desiredName + "_" + i.ToString(CultureInfo.InvariantCulture);
            } while (!localSymbols.Add(candidateName));

            return candidateName;
        }

        private string ReserveClassSymbolName(string shortName, object namedValue)
        {
            string result;
            if (namedValue != null && this.reservedSymbols.TryGetValue(namedValue, out result))
            {
                return result;
            }

            if (this.classSymbols.Add(shortName))
            {
                result = shortName;
            }
            else
            {
                int i = 0;
                string candidateName;
                do
                {
                    i++;
                    candidateName = shortName + "_" + i.ToString(CultureInfo.InvariantCulture);
                } while (!this.classSymbols.Add(candidateName));

                result = candidateName;
            }

            if (namedValue != null)
            {
                this.reservedSymbols.Add(namedValue, result);
            }

            return result;
        }

        private class LazyConstructionResult : IDisposable
        {
            private Action beforeWriteMetadata;
            private Action disposal;

            internal LazyConstructionResult(Action beforeWriteMetadata, Action disposal)
            {
                this.beforeWriteMetadata = beforeWriteMetadata;
                this.disposal = disposal;
            }

            internal LazyConstructionResult(Action disposal)
            {
                this.disposal = disposal;
            }

            internal void OnBeforeWriteMetadata()
            {
                if (this.beforeWriteMetadata != null)
                {
                    this.beforeWriteMetadata();
                    this.beforeWriteMetadata = null;
                }
            }

            public void Dispose()
            {
                this.OnBeforeWriteMetadata(); // in case the caller didn't bother with metadata.
                if (this.disposal != null)
                {
                    this.disposal();
                }
            }
        }
    }
}
