<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Microsoft.VisualStudio.Composition
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Composition.Hosting;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Composition;
using CompositionFailedException = Microsoft.VisualStudio.Composition.CompositionFailedException;

internal class CompiledExportProvider : ExportProvider
{
    protected override IEnumerable<Export> GetExportsCore(ImportDefinition importDefinition)
    {
        switch (importDefinition.ContractName)
        {
<#
foreach (var exportsByContract in this.ExportsByContract)
{
#>
            case "<#= exportsByContract.Key #>":
<#
    EmitGetExportsReturnExpression(exportsByContract, "importDefinition");
}
#>
        }

        return ImmutableList<Export>.Empty;
    }
<#
foreach (var part in this.Configuration.Parts.Where(p => p.Definition.IsInstantiable))
{
    this.localSymbols.Clear();
    var createMethod = this.CreateInstantiatePartMethod(part);
    this.extraMembers.Add(createMethod);
}

    // Emit concrete types for each metadataview interface.
    foreach (Type interfaceType in GetMetadataViewInterfaces())
    {
        string className = GetClassNameForMetadataView(interfaceType);
#>

    private class <#= className #> : <#= GetTypeName(interfaceType) #>
    {
<#
        foreach (var member in interfaceType.EnumProperties().WherePublicInstance().Distinct(UniquePropertyNameComparer.Default))
        {
#>
        private readonly <#= GetTypeName(member.PropertyType) #> <#= member.Name #>;
<#
        }
#>

        internal <#= className #>(IReadOnlyDictionary<string, object> source)
        {
<#
        foreach (var member in interfaceType.EnumProperties().WherePublicInstance().Distinct(UniquePropertyNameComparer.Default))
        {
#>
            this.<#= member.Name #> = <#= GetValueOrDefaultForMetadataView(member, "source") #>;
<#
        }
#>
        }
<#
        foreach (var member in interfaceType.EnumProperties().WherePublicInstance())
        {
#>

        <#= GetTypeName(member.PropertyType) #> <#= GetTypeName(member.DeclaringType) #>.<#= member.Name #>
        {
            get { return this.<#= member.Name #>; }
        }
<#
        }
#>
    }
<#
    }

    using (Indent())
    {
        this.EmitAdditionalMembers();
    }
#>

    public CompiledExportProvider()
        : this(null, null)
    {
    }

    public CompiledExportProvider(ExportProvider parent, string[] freshSharingBoundaries)
        : base(parent, freshSharingBoundaries)
    {
        this.cachedManifests = new Module[<#= reflectionLoadedAssemblies.Count #>];
    }
}
