<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Microsoft.VisualStudio.Composition
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Composition.Hosting;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Composition;
using CompositionFailedException = Microsoft.VisualStudio.Composition.CompositionFailedException;

internal class CompiledExportProvider : ExportProvider
{
    public CompiledExportProvider()
        : this(null, null)
    {
    }

    public CompiledExportProvider(ExportProvider parent, string[] freshSharingBoundaries)
        : base(parent, freshSharingBoundaries)
    {
    }

    protected override IEnumerable<object> GetExports(CompositionContract compositionContract)
    {
        var provisionalSharedObjects = new Dictionary<Type, object>();
        Type exportTypeDefinition = compositionContract.Type.IsGenericType ? compositionContract.Type.GetGenericTypeDefinition() : compositionContract.Type;
        switch (compositionContract.ContractName)
        {
<#
foreach (var contractNamesAndContractsAndExports in this.ExportsByContract)
{
#>
            case <#= contractNamesAndContractsAndExports.Key != null ? ("\"" + contractNamesAndContractsAndExports.Key + "\"") : "null" #>:
<#
    foreach (var contractAndExports in contractNamesAndContractsAndExports)
    {
        CompositionContract contract = contractAndExports.Key;
        IEnumerable<Export> exports = contractAndExports;
#>
                if (<#= contract.Type.IsGenericTypeDefinition ? "exportTypeDefinition" : "compositionContract.Type" #>.IsEquivalentTo(<#= GetTypeExpression(contract.Type, contract.Type.IsGenericTypeDefinition) #>))
                {
                    <# using(Indent()) EmitGetExportsReturnExpression(contract, exports); #>
                }

<#
    }
#>
                break;
<#
}
#>
        }

        return null;
    }
<#
foreach (var part in this.Configuration.Parts) 
{
#>

    protected ILazy<<#= GetTypeName(part.Definition.Type) #>> <#= GetPartFactoryMethodName(part.Definition) #>(Dictionary<Type, object> provisionalSharedObjects, bool nonSharedInstanceRequired = false)
    {
<#      if (part.Definition.Equals(ExportProvider.ExportProviderPartDefinition))
        {
            // Special case for our synthesized part that acts as a placeholder for *this* export provider.
#>
            return this.NonDisposableWrapper;
<#
        }
        else
        {
#>
        ILazy<<#= GetTypeName(part.Definition.Type) #>> value;
        Type partType = <#= this.GetTypeExpression(part.Definition.Type) #>;
        if (!nonSharedInstanceRequired && TryGetProvisionalSharedExport(provisionalSharedObjects, partType, out value))
        {
            return value;
        }

        ILazy<<#= GetTypeName(part.Definition.Type) #>> lazyResult;
<#
        if (part.Definition.IsShared)
        {
#>
        if (nonSharedInstanceRequired || !this.TryGetSharedInstanceFactory(@"<#= this.Configuration.GetEffectiveSharingBoundary(part.Definition) #>", partType, out lazyResult))
        {
            lazyResult = <# using (EmitLazyConstruction(part.Definition.Type, null)) { #>
                {
<#
                using(Indent(5))
                {
                    EmitInstantiatePart(part);
                }
#>
                }<# } #>;

            if (!nonSharedInstanceRequired)
            {
                lazyResult = this.GetOrAddSharedInstanceFactory(@"<#= this.Configuration.GetEffectiveSharingBoundary(part.Definition) #>", partType, lazyResult);
            }
        }
<#
        }
        else
        {
#>
        lazyResult = <# using (EmitLazyConstruction(part.Definition.Type, null)) { #>
            {
<#
                using(Indent(4))
                {
                    EmitInstantiatePart(part);
                }
#>
            }<# } #>;
<#
        }
#>

        return lazyResult;
<#
        } // else block for the !specialcase
#>
    }
<#
}
#>

    private static bool TryGetProvisionalSharedExport<T>(IReadOnlyDictionary<Type, object> provisionalSharedObjects, Type type, out ILazy<T> value)
    {
        object valueObject;
        if (provisionalSharedObjects.TryGetValue(type, out valueObject))
        {
            value = LazyPart.Wrap((T)valueObject);
            return true;
        }

        value = null;
        return false;
    }
<#
    // Emit concrete types for each metadataview interface.
    foreach (Type interfaceType in GetMetadataViewInterfaces())
    {
        string className = GetClassNameForMetadataView(interfaceType);
#>

    private class <#= className #> : <#= GetTypeName(interfaceType) #>
    {
<#
        foreach (var member in interfaceType.EnumProperties().WherePublicInstance().Distinct(UniquePropertyNameComparer.Default))
        {
#>
        private readonly <#= GetTypeName(member.PropertyType) #> <#= member.Name #>;
<#
        }
#>

        internal <#= className #>(IReadOnlyDictionary<string, object> source)
        {
<#
        foreach (var member in interfaceType.EnumProperties().WherePublicInstance().Distinct(UniquePropertyNameComparer.Default))
        {
#>
            this.<#= member.Name #> = <#= GetValueOrDefaultForMetadataView(member, "source") #>;
<#
        }
#>
        }
<#
        foreach (var member in interfaceType.EnumProperties().WherePublicInstance())
        {
#>

        <#= GetTypeName(member.PropertyType) #> <#= GetTypeName(member.DeclaringType) #>.<#= member.Name #>
        {
            get { return this.<#= member.Name #>; }
        }
<#
        }
#>
    }
<#
    }
#>
}
